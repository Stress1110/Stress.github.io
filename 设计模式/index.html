<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Stress's blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Stress</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/Algorithm/">Algorithm</a></li><li><a class="category-link" href="/categories/%E9%85%8D%E7%BD%AE/">配置</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 ></h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h5 id="1、什么是设计模式？"><a href="#1、什么是设计模式？" class="headerlink" title="1、什么是设计模式？"></a>1、什么是设计模式？</h5><p>设计模式指的是在软件开发中，经过反复实践证明，可以提供有效解决特定场景下问题的一系列可复用的模式。这些模式描述了在应对某些常见问题或实现某些特定功能时，常用的特定方法和思路，从而可以实现易于维护、可扩展、高可重用性和灵活性的代码。<br>设计模式有很多种，常见的有23种。这些模式根据功能和特点可以分为三类：</p>
<ul>
<li>创建型模式：这些模式用于处理对象的实例化过程，提供了一种创建对象的最佳实践方案</li>
<li>结构型模式：这些模式用于处理对象之间的关系，通过定义不同对象之间的接口和职责以及组合它们来创建更大的结构</li>
<li>行为型模式：这些模式用于处理对象之间的相互作用，定义了不同对象之间的通信和协作方式</li>
</ul>
<p>设计模式的优点是可以提高代码的重用性和可维护性，简化代码的实现，降低程序的耦合性，同时也能帮助开发人员更好地理解问题和解决问题。不过，设计模式的使用需要考虑到具体的场景和需求，不应过度应用，否则可能会导致过度设计和代码复杂度的增加。</p>
<h5 id="2、结构型模式和行为型模式有什么区别？"><a href="#2、结构型模式和行为型模式有什么区别？" class="headerlink" title="2、结构型模式和行为型模式有什么区别？"></a>2、结构型模式和行为型模式有什么区别？</h5><p>结构型模式和行为型模式是软件设计中两个不同的概念，它们分别关注不同的方面。</p>
<p>1.结构型模式（Structural Patterns）：<br>结构型模式关注的是如何组合和组织对象以构建更大的结构，以解决对象之间的关系和组织问题。它们主要用于改善对象之间的接口和关系，以更好地实现系统的结构和架构。结构型模式的目标是提供一种解决方案来处理类和对象之间的静态组合。<br>一些常见的结构型模式包括适配器模式、装饰者模式、代理模式和桥接模式等。例如，适配器模式用于将一个类的接口转换为另一个类所需的接口，以便它们可以协同工作。<br>2.行为型模式（Behavioral Patterns）：<br>行为型模式关注的是对象之间的通信和相互作用，以实现更灵活和可扩展的系统行为。它们用于描述对象之间的职责分配和合作方式，以便在系统中实现可维护和可复用的行为。行为型模式的目标是提供一种解决方案来处理对象之间的动态交互。<br>一些常见的行为型模式包括观察者模式、策略模式、模板方法模式和命令模式等。例如，观察者模式用于实现对象之间的发布-订阅机制，其中一个对象变化时会通知其他相关对象。</p>
<p>总结起来，结构型模式关注对象之间的关系和组织方式，以实现更好的系统结构，而行为型模式关注对象的相互作用和通信方式，以实现更灵活和可扩展的系统行为。两者都是重要的设计模式类别，用于解决不同层面的设计问题。在实际应用中，通常会结合使用不同的模式来满足系统的需求。</p>
<p>以下是常见的23种设计模式：</p>
<h2 id="一、创建型模式（Creational-Patterns）"><a href="#一、创建型模式（Creational-Patterns）" class="headerlink" title="一、创建型模式（Creational Patterns）:"></a>一、创建型模式（Creational Patterns）:</h2><p>这些模式用于处理对象的实例化过程，提供了一种创建对象的最佳实践方案</p>
<h4 id="1、单例模式（Singleton-Pattern）"><a href="#1、单例模式（Singleton-Pattern）" class="headerlink" title="1、单例模式（Singleton Pattern）"></a>1、单例模式（Singleton Pattern）</h4><p>单例模式是设计模式中的一种，旨在确保类只能被实例化一次，并提供一个全局的访问点来获取该实例。</p>
<p>为什么使用单例模式？</p>
<ol>
<li>资源共享：单例模式可以确保多个对象共享同一个实例，避免重复创建和浪费资源。</li>
<li>惰性创建：单例模式可以延迟对象的实例化，只有在第一次使用时才会创建实例。</li>
<li>全局访问：由于单例模式只会生成一个实例，可以通过全局访问点获取该实例，方便在整个系统中进行访问和使用。</li>
</ol>
<p>（细节：私有构造函数，防止外部实例化）</p>
<p>在Java中，可以通过以下两种常见的方式来实现单例模式：</p>
<p><strong>懒汉式（Lazy Initialization）单例模式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line">    </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        // 私有构造函数，防止外部实例化</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在懒汉式中，实例化对象的代码位于getInstance()方法中的懒加载逻辑中。这意味着在第一次调用getInstance()方法时才会创建实例。通过synchronized关键字来保证线程安全，但也会造成一定的性能开销。</p>
<p><strong>饿汉式（Eager Initialization）单例模式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line">    </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        // 私有构造函数，防止外部实例化</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在饿汉式中，实例化对象的代码位于类加载时就执行的静态代码块中。这意味着在程序启动时就会创建实例，不会延迟实例化，因此不存在线程安全问题。但可能会浪费资源，因为无论是否使用该实例，都会进行实例化。</p>
<p><strong>无论是懒汉式还是饿汉式，都需要将类的构造方法设置为私有，以防止外部类直接实例化。而获取实例的方法通常是通过静态方法来实现，以便全局访问。</strong></p>
<p>以下是使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 获取单例实例</span><br><span class="line">        Singleton instance = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        // 使用单例实例</span><br><span class="line">        instance.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、简单工厂模式（Simple-Factory-Pattern）"><a href="#2、简单工厂模式（Simple-Factory-Pattern）" class="headerlink" title="2、简单工厂模式（Simple Factory Pattern）"></a>2、简单工厂模式（Simple Factory Pattern）</h4><p>简单工厂模式（Simple Factory Pattern）是一种创建型设计模式，属于工厂模式的一种变体。它提供了一个统一的工厂类，用于根据不同的参数创建不同的产品实例，而客户端则无需关心具体的产品创建过程。</p>
<p>简单工厂模式由三个主要角色构成：</p>
<ol>
<li>工厂类（Factory）：负责根据客户端的请求创建具体产品的实例。</li>
<li>抽象产品类（Product）：定义了产品的共同接口或抽象类，具体产品类需要实现或继承该接口。</li>
<li>具体产品类（Concrete Product）：实现了抽象产品类的具体实现。</li>
</ol>
<p>为什么使用简单工厂模式？</p>
<ol>
<li>封装对象创建过程：简单工厂模式<strong>将对象的创建过程封装在一个工厂类中</strong>，客户端无需直接与具体产品类进行交互，降低了耦合度。</li>
<li>统一管理创建逻辑：工厂类集中了对象的创建逻辑，方便统一管理和维护，以及可能的后续扩展和修改。</li>
</ol>
<p>如何实现简单工厂模式？<br>下面是一个使用简单工厂模式的示例，假设有一个几何图形的绘制程序，可以绘制圆形、矩形和三角形。</p>
<p>首先，定义一个抽象图形类（Product）作为所有具体图形类的共同接口或抽象类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Shape &#123;</span><br><span class="line">    void draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，实现具体图形类（Concrete Product）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Circle implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;绘制圆形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Rectangle implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;绘制矩形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Triangle implements Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void draw() &#123;</span><br><span class="line">        System.out.println(&quot;绘制三角形&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建工厂类（Factory）负责根据客户端的请求创建具体图形对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ShapeFactory &#123;</span><br><span class="line">    public Shape createShape(String type) &#123;</span><br><span class="line">        Shape shape = null;</span><br><span class="line">        if (type.equals(&quot;circle&quot;)) &#123;</span><br><span class="line">            shape = new Circle();</span><br><span class="line">        &#125; else if (type.equals(&quot;rectangle&quot;)) &#123;</span><br><span class="line">            shape = new Rectangle();</span><br><span class="line">        &#125; else if (type.equals(&quot;triangle&quot;)) &#123;</span><br><span class="line">            shape = new Triangle();</span><br><span class="line">        &#125;</span><br><span class="line">        return shape;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码可以通过工厂类来获取所需的具体图形对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ShapeFactory factory = new ShapeFactory();</span><br><span class="line"></span><br><span class="line">        // 创建圆形</span><br><span class="line">        Shape circle = factory.createShape(&quot;circle&quot;);</span><br><span class="line">        circle.draw();</span><br><span class="line"></span><br><span class="line">        // 创建矩形</span><br><span class="line">        Shape rectangle = factory.createShape(&quot;rectangle&quot;);</span><br><span class="line">        rectangle.draw();</span><br><span class="line"></span><br><span class="line">        // 创建三角形</span><br><span class="line">        Shape triangle = factory.createShape(&quot;triangle&quot;);</span><br><span class="line">        triangle.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用简单工厂模式，客户端只需通过工厂类接口来请求具体图形实例，而无需了解具体实例的创建细节。当需要添加新的图形时，只需修改工厂类的创建逻辑即可，而不必修改客户端代码，符合开闭原则。</p>
<h4 id="3、工厂方法模式（Factory-Method-Pattern）"><a href="#3、工厂方法模式（Factory-Method-Pattern）" class="headerlink" title="3、工厂方法模式（Factory Method Pattern）"></a>3、工厂方法模式（Factory Method Pattern）</h4><p>简单工厂方法模式（Simple Factory Method Pattern）是一种创建型设计模式，它是简单工厂模式的一种变体。它通过定义一个工厂方法来创建对象，将对象的创建延迟到子类中，从而实现了更好的扩展性和灵活性。</p>
<p>简单工厂方法模式的主要角色如下：</p>
<ol>
<li>抽象产品（Product）：定义了产品的共同接口或抽象类，具体产品类需要实现或继承该接口。</li>
<li>具体产品（Concrete Product）：实现了抽象产品类的具体实现。</li>
<li>抽象工厂（Factory）：声明一个创建产品的工厂方法，由子类来实现该方法。</li>
<li>具体工厂（Concrete Factory）：实现抽象工厂中的工厂方法，用于实际创建产品的对象。</li>
</ol>
<p>为什么使用简单工厂方法模式？</p>
<ol>
<li>扩展性：简单工厂方法模式将对象的创建延迟到子类中，当需要增加新的产品时，只需要添加具体产品类和对应的具体工厂类，无需修改已有的代码。</li>
<li>解耦：客户端只与抽象产品和抽象工厂进行交互，无需知道具体产品和具体工厂的存在，降低了客户端与具体实现的耦合度。</li>
</ol>
<p>如何实现简单工厂方法模式？<br>下面是一个使用简单工厂方法模式的示例，假设有一个图表库，可以绘制不同类型的图表，如折线图（LineChart）和柱状图（BarChart）。</p>
<p>首先，定义一个抽象图表类（Product）作为所有具体图表类的共同接口或抽象类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Chart &#123;</span><br><span class="line">    void display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，实现具体图表类（Concrete Product）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LineChart implements Chart &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;显示折线图&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BarChart implements Chart &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;显示柱状图&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建抽象工厂类（Factory）来定义创建图表的工厂方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class ChartFactory &#123;</span><br><span class="line">    public abstract Chart createChart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，实现具体工厂类（Concrete Factory）来实现抽象工厂中的工厂方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class LineChartFactory extends ChartFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Chart createChart() &#123;</span><br><span class="line">        return new LineChart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BarChartFactory extends ChartFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Chart createChart() &#123;</span><br><span class="line">        return new BarChart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码可以通过具体工厂类来获取所需的具体图表对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChartFactory factory = new LineChartFactory();</span><br><span class="line">        Chart chart = factory.createChart();</span><br><span class="line">        chart.display();</span><br><span class="line"></span><br><span class="line">        factory = new BarChartFactory();</span><br><span class="line">        chart = factory.createChart();</span><br><span class="line">        chart.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用简单工厂方法模式，客户端只需与抽象产品和抽象工厂进行交互，可以根据需要选择具体的工厂类来创建相应的产品对象。当需要添加新的图表类型时，只需创建对应的具体产品和具体工厂类即可，而不会影响已有的代码。这种方式提供了更好的灵活性和可扩展性。</p>
<h4 id="4、抽象工厂模式（Abstract-Factory-Pattern）"><a href="#4、抽象工厂模式（Abstract-Factory-Pattern）" class="headerlink" title="4、抽象工厂模式（Abstract Factory Pattern）"></a>4、抽象工厂模式（Abstract Factory Pattern）</h4><p>抽象工厂模式（Abstract Factory Pattern）是一种创建型设计模式，它提供了一种将对象的创建与使用分离的方式。抽象工厂模式通过定义一个抽象工厂接口，该接口声明了一组创建相关或依赖对象的方法，具体工厂类实现了这个接口并实现了具体的对象创建逻辑。客户端通过使用抽象工厂接口来创建对象，从而实现了对象的解耦和灵活性。</p>
<p>抽象工厂模式的主要角色如下：</p>
<ol>
<li>抽象工厂（Abstract Factory）：定义了一组创建产品对象的方法，每个方法对应一种产品。</li>
<li>具体工厂（Concrete Factory）：实现抽象工厂接口，负责具体产品对象的创建。</li>
<li>抽象产品（Abstract Product）：定义了产品的共同接口或抽象类。</li>
<li>具体产品（Concrete Product）：实现了抽象产品类的具体实现。</li>
</ol>
<p>为什么使用抽象工厂模式？</p>
<ol>
<li>解耦：抽象工厂模式将对象的创建与使用分离，客户端只需通过抽象工厂接口来创建对象，无需关注具体的产品类和创建细节，降低了客户端与具体实现的耦合度。</li>
<li>可扩展性：当需要添加新的产品族时，只需要扩展抽象工厂和具体工厂类，无需修改已有的代码。</li>
<li>提供一致性：抽象工厂模式确保了一组相关的产品对象被同时创建，保证了这些产品对象的一致性。</li>
</ol>
<p>如何实现抽象工厂模式？<br>下面是一个使用抽象工厂模式的示例，假设有一个图形库，需要支持不同操作系统下的按钮（Button）和文本框（TextField）。</p>
<p>首先，定义抽象按钮类（Abstract Product）和抽象文本框类（Abstract Product）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface Button &#123;</span><br><span class="line">    void click();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface TextField &#123;</span><br><span class="line">    void input();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，实现具体按钮类（Concrete Product）和具体文本框类（Concrete Product）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class WindowsButton implements Button &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void click() &#123;</span><br><span class="line">        System.out.println(&quot;Windows Button clicked&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class WindowsTextField implements TextField &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void input() &#123;</span><br><span class="line">        System.out.println(&quot;Windows TextField input&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MacButton implements Button &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void click() &#123;</span><br><span class="line">        System.out.println(&quot;Mac Button clicked&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MacTextField implements TextField &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void input() &#123;</span><br><span class="line">        System.out.println(&quot;Mac TextField input&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，定义抽象工厂类（Abstract Factory）来声明创建按钮和文本框的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface GUIFactory &#123;</span><br><span class="line">    Button createButton();</span><br><span class="line">    TextField createTextField();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，实现具体工厂类（Concrete Factory）来实现抽象工厂中的方法，分别创建相应的按钮和文本框：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class WindowsFactory implements GUIFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Button createButton() &#123;</span><br><span class="line">        return new WindowsButton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public TextField createTextField() &#123;</span><br><span class="line">        return new WindowsTextField();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MacFactory implements GUIFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Button createButton() &#123;</span><br><span class="line">        return new MacButton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public TextField createTextField() &#123;</span><br><span class="line">        return new MacTextField();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码可以通过具体工厂类来获取所需的按钮和文本框对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        GUIFactory factory = new WindowsFactory();</span><br><span class="line">        Button button = factory.createButton();</span><br><span class="line">        TextField textField = factory.createTextField();</span><br><span class="line"></span><br><span class="line">        button.click();</span><br><span class="line">        textField.input();</span><br><span class="line"></span><br><span class="line">        factory = new MacFactory();</span><br><span class="line">        button = factory.createButton();</span><br><span class="line">        textField = factory.createTextField();</span><br><span class="line"></span><br><span class="line">        button.click();</span><br><span class="line">        textField.input();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用抽象工厂模式，客户端只需与抽象工厂接口进行交互，通过具体工厂类来获取所需的产品对象。客户端无需关注具体产品类和创建细节，提供了解耦和灵活性。当需要增加新的产品族时，只需创建对应的抽象产品和具体产品类，并实现相应的抽象工厂接口和具体工厂类即可，而不会影响已有的代码。这种方式提供了更好的可扩展性和一致性</p>
<h4 id="5、建造者模式（Builder-Pattern）"><a href="#5、建造者模式（Builder-Pattern）" class="headerlink" title="5、建造者模式（Builder Pattern）"></a>5、建造者模式（Builder Pattern）</h4><p>建造者模式（Builder Pattern）是一种创建型设计模式，用于创建复杂对象。它将对象的构建过程与表示分离，允许按照步骤或顺序构建对象，从而使构建过程更加灵活和可控。</p>
<p>建造者模式的主要角色如下：</p>
<ol>
<li>产品类（Product）：表示被构建的复杂对象。</li>
<li>抽象建造者（Abstract Builder）：声明构建产品的方法，并定义获取最终产品的方法。</li>
<li>具体建造者（Concrete Builder）：实现抽象建造者接口，具体实现产品的构建过程，并返回最终的产品对象。</li>
<li>指挥者（Director）：负责按照指定的步骤或顺序调用建造者的方法来构建产品。</li>
</ol>
<p>为什么使用建造者模式？<br>建造者模式的主要优点包括：</p>
<ol>
<li>分离构建过程与表示：通过建造者模式，可以将复杂对象的构建过程与表示分离开来，使得同样的构建过程可以创建不同的表示。</li>
<li>更好的控制构建过程：建造者模式允许按照步骤或顺序构建对象，可以更加灵活地控制构建过程，满足不同的需求。</li>
<li>提供更好的复用性：通过定义不同的具体建造者类，可以在构建过程中重用相同的构建逻辑，提高代码复用性。</li>
</ol>
<p>如何使用建造者模式？<br>下面是一个使用建造者模式的示例，假设有一个电脑类（Computer），它有许多可选的组件，如CPU、内存、硬盘等。我们通过建造者模式来构建电脑对象。</p>
<p>首先，定义电脑类（Product），并声明一些设置组件的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Computer &#123;</span><br><span class="line">    private String cpu;</span><br><span class="line">    private String memory;</span><br><span class="line">    private String hardDisk;</span><br><span class="line"></span><br><span class="line">    public void setCPU(String cpu) &#123;</span><br><span class="line">        this.cpu = cpu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMemory(String memory) &#123;</span><br><span class="line">        this.memory = memory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHardDisk(String hardDisk) &#123;</span><br><span class="line">        this.hardDisk = hardDisk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // other methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，定义抽象建造者接口（Abstract Builder），声明设置组件的方法和获取最终产品的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public interface ComputerBuilder &#123;</span><br><span class="line">    void setCPU();</span><br><span class="line">    void setMemory();</span><br><span class="line">    void setHardDisk();</span><br><span class="line">    Computer getComputer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，实现具体建造者类（Concrete Builder），实现抽象建造者接口并负责具体的构建过程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class DesktopComputerBuilder implements ComputerBuilder &#123;</span><br><span class="line">    private Computer computer;</span><br><span class="line"></span><br><span class="line">    public DesktopComputerBuilder() &#123;</span><br><span class="line">        this.computer = new Computer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setCPU() &#123;</span><br><span class="line">        computer.setCPU(&quot;Desktop CPU&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setMemory() &#123;</span><br><span class="line">        computer.setMemory(&quot;Desktop Memory&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setHardDisk() &#123;</span><br><span class="line">        computer.setHardDisk(&quot;Desktop Hard Disk&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Computer getComputer() &#123;</span><br><span class="line">        return computer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，定义指挥者类（Director），负责按照指定顺序调用建造者的方法来构建产品：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Director &#123;</span><br><span class="line">    private ComputerBuilder computerBuilder;</span><br><span class="line"></span><br><span class="line">    public void setComputerBuilder(ComputerBuilder computerBuilder) &#123;</span><br><span class="line">        this.computerBuilder = computerBuilder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Computer getComputer() &#123;</span><br><span class="line">        return computerBuilder.getComputer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void constructComputer() &#123;</span><br><span class="line">        computerBuilder.setCPU();</span><br><span class="line">        computerBuilder.setMemory();</span><br><span class="line">        computerBuilder.setHardDisk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端代码可以使用指挥者类来进行产品的构建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用DesktopComputerBuilder构建DesktopComputer</span></span><br><span class="line">        <span class="type">ComputerBuilder</span> <span class="variable">desktopBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DesktopComputerBuilder</span>();</span><br><span class="line">        director.setComputerBuilder(desktopBuilder);</span><br><span class="line"></span><br><span class="line">        director.constructComputer();</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">desktopComputer</span> <span class="operator">=</span> director.getComputer();</span><br><span class="line">        System.out.println(<span class="string">&quot;Desktop Computer: &quot;</span> + desktopComputer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用LaptopComputerBuilder构建LaptopComputer</span></span><br><span class="line">        <span class="type">ComputerBuilder</span> <span class="variable">laptopBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LaptopComputerBuilder</span>();</span><br><span class="line">        director.setComputerBuilder(laptopBuilder);</span><br><span class="line"></span><br><span class="line">        director.constructComputer();</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">laptopComputer</span> <span class="operator">=</span> director.getComputer();</span><br><span class="line">        System.out.println(<span class="string">&quot;Laptop Computer: &quot;</span> + laptopComputer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过使用建造者模式，客户端可以通过指挥者类来控制产品的构建过程，具体的构建逻辑被封装在具体建造者类中。不同的具体建造者类可以实现不同的构建过程，从而创建不同的产品对象。这种方式提供了更好的灵活性和可拓展性，使得构建过程和产品表示分离开来。</p>
<p>注意：在上面的示例中，为简化代码，省略了LaptopComputerBuilder等具体建造者类的定义，读者可以根据需要自行扩展</p>
<h4 id="6、原型模式（Prototype-Pattern）"><a href="#6、原型模式（Prototype-Pattern）" class="headerlink" title="6、原型模式（Prototype Pattern）"></a>6、原型模式（Prototype Pattern）</h4><p>原型模式（Prototype Pattern）是一种创建型设计模式，它通过复制（克隆）现有对象来创建新对象，而不是通过实例化类。它允许我们在运行时创建新对象，同时避免了显式的依赖于特定类的实例化过程。原型模式通过克隆对象来创建新的对象，可以减少对象创建的开销，并提供更灵活的创建方式。</p>
<p>在原型模式中，每一个可克隆的类都必须实现一个<code>Cloneable</code>接口，并重写<code>clone()</code>方法。<code>clone()</code>方法用于复制对象并创建一个新的副本。有两种类型的克隆：浅克隆和深克隆。浅克隆会复制对象的基本数据类型和引用类型的引用，而深克隆会递归复制引用类型的对象。根据具体的需求选择适当的克隆方式。</p>
<p>为什么使用原型模式？</p>
<ol>
<li>避免重复的初始化过程：当创建新对象的过程比较复杂且耗时时，使用原型模式可以避免重复的初始化过程，提升性能。</li>
<li>简化对象创建：原型模式通过复制现有对象来创建新对象，简化了创建过程，尤其是当对象的创建需要复杂的构造函数或配置参数时。</li>
<li>动态扩展对象：通过原型模式，我们可以基于现有的对象创建新的对象，并根据需要进行修改、调整或添加新的属性，实现动态扩展和变化。</li>
</ol>
<p>如何使用原型模式？<br>下面是一个使用原型模式的示例，假设我们有一个网站类（Website），包含网站名称和网站页面的列表。我们通过原型模式创建不同类型的网站对象。</p>
<p>首先，定义网站类，并实现<code>Cloneable</code>接口并重写<code>clone()</code>方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Website implements Cloneable &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private List&lt;String&gt; pages;</span><br><span class="line"></span><br><span class="line">    public Website() &#123;</span><br><span class="line">        this.pages = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addPage(String page) &#123;</span><br><span class="line">        this.pages.add(page);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void printPages() &#123;</span><br><span class="line">        System.out.println(pages);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Website clone() throws CloneNotSupportedException &#123;</span><br><span class="line">        Website clonedWebsite = (Website) super.clone();</span><br><span class="line">        clonedWebsite.pages = new ArrayList&lt;&gt;(this.pages);</span><br><span class="line">        return clonedWebsite;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们可以创建一个原始的网站对象，并设置名称和页面列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Website originalWebsite = new Website();</span><br><span class="line">originalWebsite.setName(&quot;Original Website&quot;);</span><br><span class="line">originalWebsite.addPage(&quot;Home&quot;);</span><br><span class="line">originalWebsite.addPage(&quot;About&quot;);</span><br><span class="line">originalWebsite.addPage(&quot;Contact&quot;);</span><br><span class="line"></span><br><span class="line">originalWebsite.printPages(); // Output: [Home, About, Contact]</span><br></pre></td></tr></table></figure>

<p>接下来，我们可以基于原始的网站对象创建新的网站对象，每个网站对象可以根据需要进行修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Website clonedWebsite = originalWebsite.clone();</span><br><span class="line">clonedWebsite.setName(&quot;Cloned Website&quot;);</span><br><span class="line"></span><br><span class="line">clonedWebsite.addPage(&quot;Products&quot;);</span><br><span class="line">clonedWebsite.printPages(); // Output: [Home, About, Contact, Products]</span><br></pre></td></tr></table></figure>

<p>通过原型模式，我们创建了一个新的网站对象，并在该对象的基础上添加了新的页面，同时保留了原始网站对象的数据。这样可以灵活地创建和修改对象，符合动态扩展的需求。</p>
<p>需要注意的是，在Java中，<code>clone()</code>方法是浅克隆，会复制对象的基本数据类型和引用类型的引用。如果需要深克隆，即复制引用类型的对象本身而不仅仅是引用，我们需要在<code>clone()</code>方法中递归复制引用对象的数据，确保每个对象都是全新的副本。</p>
<p>总结来说，原型模式通过复制现有对象来创建新对象，简化了对象的创建过程，并提供了动态扩展和变化的能力。它适用于创建过程复杂、耗时的对象，以及需要动态扩展和修改对象的场景。使用原型模式可以提高代码的可维护性和扩展性。</p>
<h2 id="二、结构型模式（Structural-Patterns）"><a href="#二、结构型模式（Structural-Patterns）" class="headerlink" title="二、结构型模式（Structural Patterns）:"></a>二、结构型模式（Structural Patterns）:</h2><p>这些模式用于处理对象之间的关系，通过定义不同对象之间的接口和职责以及组合它们来创建更大的结构</p>
<h4 id="1、适配器模式（Adapter-Pattern）"><a href="#1、适配器模式（Adapter-Pattern）" class="headerlink" title="1、适配器模式（Adapter Pattern）"></a>1、适配器模式（Adapter Pattern）</h4><p>适配器模式（Adapter Pattern）是一种结构型设计模式，用于将一个类的接口转换成客户端所期望的另一个接口。适配器模式解决了两个不兼容接口之间的兼容性问题，使得原本由于接口不匹配而不能一起工作的类可以协同工作。</p>
<p>适配器模式通常由三个角色组成：</p>
<ol>
<li>目标接口（Target Interface）：客户端所期望的接口，适配器将源接口转换为目标接口，使得客户端可以通过目标接口与适配器进行交互。</li>
<li>源接口（Adaptee Interface）：需要被适配的接口或类。</li>
<li>适配器（Adapter）：将源接口转换为目标接口的中间类，它实现了目标接口，并持有一个源接口的实例，通过对源接口的调用来实现目标接口的功能。</li>
</ol>
<p>为什么使用适配器模式？</p>
<ol>
<li>兼容性问题：当现有的接口不符合客户端的需求时，使用适配器模式可以解决兼容性问题，避免重写或修改已有代码。</li>
<li>增强可复用性：适配器模式可以使得不相关的类可以一起工作，提高代码的可复用性。</li>
<li>隐藏实现细节：适配器模式将源接口的实现细节隐藏在适配器中，让客户端不需要关注具体的实现，只需通过目标接口进行操作。</li>
</ol>
<p>如何使用适配器模式？<br>下面是一个使用适配器模式的示例，假设我们有一个播放器（MediaPlayer）接口，其中定义了播放音频和视频的方法。我们有一个现有的视频播放器（VideoPlayer），但我们希望能够使用该播放器播放音频文件。现在，我们需要一个适配器来将音频播放转换为视频播放，以适应MediaPlayer的接口。</p>
<p>首先，定义播放器接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface MediaPlayer &#123;</span><br><span class="line">    void playAudio(String fileName);</span><br><span class="line">    void playVideo(String fileName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，实现现有的视频播放器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class VideoPlayer &#123;</span><br><span class="line">    public void playVideo(String fileName) &#123;</span><br><span class="line">        System.out.println(&quot;Playing video: &quot; + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建适配器类，实现MediaPlayer接口，并持有VideoPlayer实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class AudioAdapter implements MediaPlayer &#123;</span><br><span class="line">    private VideoPlayer videoPlayer;</span><br><span class="line"></span><br><span class="line">    public AudioAdapter() &#123;</span><br><span class="line">        this.videoPlayer = new VideoPlayer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void playAudio(String fileName) &#123;</span><br><span class="line">        // 使用适配器将音频播放转换为视频播放</span><br><span class="line">        videoPlayer.playVideo(fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void playVideo(String fileName) &#123;</span><br><span class="line">        videoPlayer.playVideo(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以通过适配器来播放音频文件了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MediaPlayer audioPlayer = new AudioAdapter();</span><br><span class="line">audioPlayer.playAudio(&quot;song.mp3&quot;); // 使用适配器将音频播放转换为视频播放</span><br></pre></td></tr></table></figure>

<p>通过适配器模式，我们在不修改原有的视频播放器类的情况下，使其能够处理音频播放的需求。适配器类充当了一个桥梁，将原有类的接口转换为客户端所期望的接口，实现了两者的兼容性。</p>
<p>需要注意的是，适配器模式有两种实现方式：类适配器和对象适配器。上面的示例是对象适配器的实现方式，通过持有源接口的实例来实现目标接口。而类适配器是通过多继承（在Java中不直接支持）来实现适配器，它同时继承源接口和目标接口。根据具体的情况选择适合的实现方式。</p>
<p>总结来说，适配器模式可以将不兼容的接口转换为客户端所期望的接口，解决了接口之间的兼容性问题，同时增加了代码的可复用性和灵活性。使用适配器模式可以在不修改已有代码的情况下，将不相关的类适配为可以一起工作的类。</p>
<h4 id="2、桥接模式（Bridge-Pattern）"><a href="#2、桥接模式（Bridge-Pattern）" class="headerlink" title="2、桥接模式（Bridge Pattern）"></a>2、桥接模式（Bridge Pattern）</h4><p>桥接模式（Bridge Pattern）是一种结构型设计模式，用于将抽象部分与其实现部分分离，使它们可以独立变化。桥接模式通过将继承关系改为组合关系，来避免类的爆炸性增长，提高系统的可扩展性。</p>
<p>桥接模式通常由四个角色组成：</p>
<ol>
<li>抽象部分（Abstraction）：定义了抽象部分的接口，通常包含一个对实现部分的引用。</li>
<li>具体抽象部分（Refined Abstraction）：是抽象部分的子类，扩展了抽象部分的功能。</li>
<li>实现部分（Implementor）：定义了实现部分的接口，提供了实现部分的具体实现。</li>
<li>具体实现部分（Concrete Implementor）：实现了实现部分的接口，提供了具体的实现。</li>
</ol>
<p>为什么要使用桥接模式呢？</p>
<ol>
<li>分离抽象和实现：桥接模式分离了抽象部分和实现部分，使它们可以独立变化。这样一来，抽象部分和实现部分可以独立地扩展和修改，互不影响。</li>
<li>减少类的爆炸性增长：如果不使用桥接模式，当有多个抽象部分和实现部分的组合时，需要定义大量的子类来处理所有可能的组合情况，导致类的数量呈指数级增长。而桥接模式通过将继承关系改为组合关系，避免了类的爆炸性增长。</li>
</ol>
<p>怎么使用桥接模式呢？<br>为了更好地理解桥接模式，以下是一个示例：假设我们要设计一个远程控制器，可以控制不同类型的设备，如电视和音响。不同的设备有不同的控制接口，而远程控制器可以灵活地切换不同类型的设备。我们可以通过桥接模式来设计这个系统。</p>
<p>首先，定义抽象部分的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface RemoteControl &#123;</span><br><span class="line">    void powerOn();</span><br><span class="line">    void powerOff();</span><br><span class="line">    void setDevice(Device device);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建具体的抽象部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class BasicRemoteControl implements RemoteControl &#123;</span><br><span class="line">    protected Device device;</span><br><span class="line"></span><br><span class="line">    public void setDevice(Device device) &#123;</span><br><span class="line">        this.device = device;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void powerOn() &#123;</span><br><span class="line">        device.powerOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void powerOff() &#123;</span><br><span class="line">        device.powerOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，定义实现部分的接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Device &#123;</span><br><span class="line">    void powerOn();</span><br><span class="line">    void powerOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建具体的实现部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TV implements Device &#123;</span><br><span class="line">    public void powerOn() &#123;</span><br><span class="line">        System.out.println(&quot;TV is powered on&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void powerOff() &#123;</span><br><span class="line">        System.out.println(&quot;TV is powered off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Stereo implements Device &#123;</span><br><span class="line">    public void powerOn() &#123;</span><br><span class="line">        System.out.println(&quot;Stereo is powered on&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void powerOff() &#123;</span><br><span class="line">        System.out.println(&quot;Stereo is powered off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以通过桥接模式来控制不同类型的设备：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Device tv = new TV();</span><br><span class="line">RemoteControl remoteControl = new BasicRemoteControl();</span><br><span class="line">remoteControl.setDevice(tv);</span><br><span class="line">remoteControl.powerOn();  // 控制电视打开</span><br><span class="line">remoteControl.powerOff(); // 控制电视关闭</span><br><span class="line"></span><br><span class="line">Device stereo = new Stereo();</span><br><span class="line">remoteControl.setDevice(stereo);</span><br><span class="line">remoteControl.powerOn();  // 控制音响打开</span><br><span class="line">remoteControl.powerOff(); // 控制音响关闭</span><br></pre></td></tr></table></figure>

<p>通过桥接模式，我们将抽象部分（RemoteControl）与实现部分（Device）分离开来，使它们可以独立变化。我们可以轻松地添加新的设备和控制方式，而不需要修改已有的代码。</p>
<p>总结来说，桥接模式通过分离抽象部分和实现部分，使它们可以独立变化，提高系统的灵活性和可扩展性。使用桥接模式可以避免类的爆炸性增长，并提供更好的代码组织和可维护性</p>
<h4 id="3、组合模式（Composite-Pattern）"><a href="#3、组合模式（Composite-Pattern）" class="headerlink" title="3、组合模式（Composite Pattern）"></a>3、组合模式（Composite Pattern）</h4><p>组合模式（Composite Pattern）是一种结构型设计模式，用于将对象组合成树状结构以表示”整体-部分”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性，可以简化对复杂结构的操作。</p>
<p>组合模式通常由以下角色组成：</p>
<ol>
<li>组件（Component）：定义组合对象和叶子对象的共同接口，并提供默认实现，包括添加、删除、获取子节点等操作。</li>
<li>叶子（Leaf）：表示组合中的叶子节点对象，叶子节点没有子节点。</li>
<li>组合（Composite）：表示组合中的容器节点对象，可以包含子节点。组合实现了组件接口，并提供了操作子节点的方法。</li>
</ol>
<p>为什么要使用组合模式呢？</p>
<ol>
<li>对象的统一访问：使用组合模式可以统一对单个对象和组合对象的访问方式，将它们看作是同一类型的对象。</li>
<li>简化操作复杂结构：组合模式使得处理复杂层次结构的对象变得简单，通过组合对象和叶子对象的统一接口，可以对整个结构进行统一的操作，无需关心对象的具体类型。</li>
</ol>
<p>怎么使用组合模式呢？<br>为了更好地理解组合模式，以下是一个示例：假设我们要设计一个多层文件系统，包括文件和文件夹。文件夹可以包含文件和其他子文件夹，文件和文件夹都可以进行某些操作，如获取名称、显示信息等。我们可以使用组合模式来设计这个系统。</p>
<p>首先，定义组件接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface FileSystemComponent &#123;</span><br><span class="line">    void display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建叶子类文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class File implements FileSystemComponent &#123;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public File(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;File: &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建组合类文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Folder implements FileSystemComponent &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private List&lt;FileSystemComponent&gt; components;</span><br><span class="line"></span><br><span class="line">    public Folder(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.components = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addComponent(FileSystemComponent component) &#123;</span><br><span class="line">        components.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void removeComponent(FileSystemComponent component) &#123;</span><br><span class="line">        components.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display() &#123;</span><br><span class="line">        System.out.println(&quot;Folder: &quot; + name);</span><br><span class="line">        for (FileSystemComponent component : components) &#123;</span><br><span class="line">            component.display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以使用组合模式来组合文件和文件夹，形成多层的文件系统：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 创建文件</span><br><span class="line">FileSystemComponent file1 = new File(&quot;file1.txt&quot;);</span><br><span class="line">FileSystemComponent file2 = new File(&quot;file2.txt&quot;);</span><br><span class="line"></span><br><span class="line">// 创建文件夹</span><br><span class="line">Folder folder1 = new Folder(&quot;folder1&quot;);</span><br><span class="line">Folder folder2 = new Folder(&quot;folder2&quot;);</span><br><span class="line"></span><br><span class="line">// 组合文件和文件夹</span><br><span class="line">folder1.addComponent(file1);</span><br><span class="line">folder2.addComponent(file2);</span><br><span class="line">folder1.addComponent(folder2);</span><br><span class="line"></span><br><span class="line">// 显示文件系统</span><br><span class="line">folder1.display();</span><br></pre></td></tr></table></figure>

<p>通过组合模式，我们可以将文件和文件夹统一看作是<code>FileSystemComponent</code>类型的对象，无论是对文件还是对文件夹进行操作，使用相同的接口进行访问和处理。</p>
<p>总结来说，组合模式可以简化处理复杂层次结构的对象，使得用户对单个对象和组合对象具有一致性。使用组合模式可以统一访问方式，减少对对象类型的判断，提高代码的可扩展性和可维护性。</p>
<h4 id="4、装饰者模式（Decorator-Pattern）"><a href="#4、装饰者模式（Decorator-Pattern）" class="headerlink" title="4、装饰者模式（Decorator Pattern）"></a>4、装饰者模式（Decorator Pattern）</h4><p>装饰者模式（Decorator Pattern）是一种结构型设计模式，允许你动态地将新功能添加到对象中，同时保持对象的接口不变。它通过将对象放入包装器（装饰者）中来实现扩展，而不是通过继承来实现。装饰者模式遵循开放封闭原则，允许在不修改现有代码的情况下添加新功能。</p>
<p>在装饰者模式中，有以下角色：</p>
<ol>
<li>组件（Component）：定义了对象的接口。可以是抽象类或接口。</li>
<li>具体组件（Concrete Component）：实现了组件接口的具体对象。</li>
<li><strong>装饰者（Decorator）：持有一个组件对象的引用，并实现与组件接口一致的接口。它可以通过组合的方式，在运行时动态地为组件对象添加新的行为。</strong></li>
<li>具体装饰者（Concrete Decorator）：具体的装饰者实现，通过扩展装饰者中的方法来添加新功能。</li>
</ol>
<p>为什么要使用装饰者模式呢？</p>
<ol>
<li>动态扩展：装饰者模式允许在运行时动态地为对象添加功能，而不影响其接口和其他对象的使用。</li>
<li>避免类爆炸：相比子类继承，装饰者模式通过组合的方式实现功能的添加，避免了类的爆炸问题。</li>
</ol>
<p>下面是一个使用装饰者模式的示例：假设我们有一个咖啡店，需要实现咖啡的价格计算功能。咖啡有不同的种类，例如浓缩咖啡（Espresso）、拿铁咖啡（Latte）等，并且可以选择添加不同的配料，如牛奶（Milk）、摩卡（Mocha）等。我们希望能够动态地为咖啡添加不同的配料，并计算最终的价格。</p>
<p>首先，定义组件接口（咖啡）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Coffee &#123;</span><br><span class="line">    double getCost();</span><br><span class="line">    String getDescription();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建具体组件（不同种类的咖啡）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Espresso implements Coffee &#123;</span><br><span class="line">    public double getCost() &#123;</span><br><span class="line">        return 1.5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return &quot;Espresso&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Latte implements Coffee &#123;</span><br><span class="line">    public double getCost() &#123;</span><br><span class="line">        return 2.5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return &quot;Latte&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建装饰者类和具体装饰者类（配料）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public abstract class CoffeeDecorator implements Coffee &#123;</span><br><span class="line">    protected Coffee coffee;</span><br><span class="line"></span><br><span class="line">    public CoffeeDecorator(Coffee coffee) &#123;</span><br><span class="line">        this.coffee = coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Milk extends CoffeeDecorator &#123;</span><br><span class="line">    public Milk(Coffee coffee) &#123;</span><br><span class="line">        super(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getCost() &#123;</span><br><span class="line">        return coffee.getCost() + 0.5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return coffee.getDescription() + &quot;, Milk&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Mocha extends CoffeeDecorator &#123;</span><br><span class="line">    public Mocha(Coffee coffee) &#123;</span><br><span class="line">        super(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double getCost() &#123;</span><br><span class="line">        return coffee.getCost() + 0.7;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDescription() &#123;</span><br><span class="line">        return coffee.getDescription() + &quot;, Mocha&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以动态地为咖啡添加不同的配料：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 创建浓缩咖啡</span><br><span class="line">Coffee espresso = new Espresso();</span><br><span class="line">System.out.println(&quot;Cost: &quot; + espresso.getCost() + &quot;, Description: &quot; + espresso.getDescription());</span><br><span class="line"></span><br><span class="line">// 添加牛奶</span><br><span class="line">Coffee latteWithMilk = new Milk(new Latte());</span><br><span class="line">System.out.println(&quot;Cost: &quot; + latteWithMilk.getCost() + &quot;, Description: &quot; + latteWithMilk.getDescription());</span><br><span class="line"></span><br><span class="line">// 添加牛奶和摩卡</span><br><span class="line">Coffee latteWithMilkAndMocha = new Mocha(new Milk(new Latte()));</span><br><span class="line">System.out.println(&quot;Cost: &quot; + latteWithMilkAndMocha.getCost() + &quot;, Description: &quot; + latteWithMilkAndMocha.getDescription());</span><br></pre></td></tr></table></figure>

<p>通过装饰者模式，我们可以在不修改现有咖啡类的情况下，动态地为其添加不同的配料，并计算最终的价格和描述信息。</p>
<p>总结来说，装饰者模式允许你通过组合的方式动态地为对象添加新功能，同时保持接口不变。它提供了一种灵活且可扩展的方式来修改对象的行为，避免了类爆炸问题。使用装饰者模式可以实现透明的对象扩展，保持代码的可读性和可维护性</p>
<h4 id="5、外观模式（Facade-Pattern）"><a href="#5、外观模式（Facade-Pattern）" class="headerlink" title="5、外观模式（Facade Pattern）"></a>5、外观模式（Facade Pattern）</h4><p>外观模式（Facade Pattern）是一种结构型设计模式，它提供了一个统一的接口，用于访问子系统中的一组接口。外观模式隐藏了子系统的复杂性，客户端可以通过调用外观对象的方法来简化操作，而不需要直接与子系统的组件交互。外观模式注重简化接口，提供一个简单而统一的界面来与复杂子系统进行交互。</p>
<p>为什么要使用外观模式呢？</p>
<ol>
<li>简化接口：外观模式可以封装一组复杂的子系统接口，向客户端提供一个简单、易于使用的接口，降低了客户端与子系统之间的耦合度。</li>
<li>提供高层接口：通过外观对象，客户端可以轻松地调用多个子系统接口的组合操作，简化了客户端的逻辑。</li>
<li>提供子系统的解耦：外观模式将客户端与子系统解耦，客户端只需要与外观对象进行交互，不需要关心子系统内部的具体实现细节。</li>
</ol>
<p>下面是一个使用外观模式的示例：假设我们有一个家庭影院系统，包括音响、投影仪和DVD播放器等子系统。我们希望提供一个简化的接口，使客户端可以通过一个按钮来启动整个家庭影院系统。</p>
<p>首先，定义子系统的接口和具体实现类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// 子系统：音响</span><br><span class="line">public class StereoSystem &#123;</span><br><span class="line">    public void turnOn() &#123;</span><br><span class="line">        System.out.println(&quot;音响已打开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;音响已关闭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子系统：投影仪</span><br><span class="line">public class Projector &#123;</span><br><span class="line">    public void turnOn() &#123;</span><br><span class="line">        System.out.println(&quot;投影仪已打开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;投影仪已关闭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 子系统：DVD播放器</span><br><span class="line">public class DVDPlayer &#123;</span><br><span class="line">    public void turnOn() &#123;</span><br><span class="line">        System.out.println(&quot;DVD播放器已打开&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;DVD播放器已关闭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建外观类（家庭影院）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class HomeTheaterFacade &#123;</span><br><span class="line">    private StereoSystem stereo;</span><br><span class="line">    private Projector projector;</span><br><span class="line">    private DVDPlayer dvdPlayer;</span><br><span class="line"></span><br><span class="line">    public HomeTheaterFacade() &#123;</span><br><span class="line">        this.stereo = new StereoSystem();</span><br><span class="line">        this.projector = new Projector();</span><br><span class="line">        this.dvdPlayer = new DVDPlayer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void watchMovie() &#123;</span><br><span class="line">        stereo.turnOn();</span><br><span class="line">        projector.turnOn();</span><br><span class="line">        dvdPlayer.turnOn();</span><br><span class="line">        System.out.println(&quot;影院系统已启动&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void stopMovie() &#123;</span><br><span class="line">        stereo.turnOff();</span><br><span class="line">        projector.turnOff();</span><br><span class="line">        dvdPlayer.turnOff();</span><br><span class="line">        System.out.println(&quot;影院系统已关闭&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们可以使用外观模式来控制家庭影院系统：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HomeTheaterFacade facade = new HomeTheaterFacade();</span><br><span class="line"></span><br><span class="line">// 启动家庭影院系统</span><br><span class="line">facade.watchMovie();</span><br><span class="line"></span><br><span class="line">// 停止家庭影院系统</span><br><span class="line">facade.stopMovie();</span><br></pre></td></tr></table></figure>

<p>通过外观模式，我们可以通过调用外观对象的方法来启动和关闭整个家庭影院系统，而不需要了解子系统的具体操作细节。</p>
<p>总结来说，外观模式提供了一个简化而统一的接口，用于访问子系统中的一组接口。它将复杂的子系统封装起来，降低了客户端与子系统之间的耦合度。使用外观模式可以提供高层接口，简化客户端的逻辑，并提供解耦的特性，使得系统更加灵活和可维护。</p>
<h4 id="6、享元模式（Flyweight-Pattern）"><a href="#6、享元模式（Flyweight-Pattern）" class="headerlink" title="6、享元模式（Flyweight Pattern）"></a>6、享元模式（Flyweight Pattern）</h4><p>享元模式（Flyweight Pattern）是一种结构型设计模式，用于有效地支持大量细粒度的对象共享。它通过共享相似对象之间的公共部分来减少对象的数量，从而节省内存和提高性能。享元模式适用于需要创建大量相似对象的场景，通过共享对象的方式来减少内存消耗和对象创建的开销。</p>
<p>为什么要使用享元模式呢？<br>在某些情况下，如果系统中存在大量相似的对象，每个对象都占用较大的内存空间，那么会导致内存占用过高，严重影响系统性能。通过使用享元模式，可以将这些相似的对象共享一部分内部状态，从而达到减少内存占用的目的。</p>
<p>下面是一个使用享元模式的示例：假设我们正在开发一个文本编辑器，我们希望在编辑器中显示多个文本字符，并根据每个字符的属性（如字体、颜色等）进行展示。但是由于字符数量很多，如果每个字符都创建一个新的对象，将会占用大量的内存。</p>
<p>首先，我们定义一个抽象的文本字符类<code>TextCharacter</code>，其中包含共享的内部状态和非共享的外部状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public abstract class TextCharacter &#123;</span><br><span class="line">    protected String font;</span><br><span class="line">    protected int size;</span><br><span class="line"></span><br><span class="line">    public abstract void display(int x, int y, String color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，我们创建具体的享元类<code>SharedTextCharacter</code>，它表示共享的文本字符对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class SharedTextCharacter extends TextCharacter &#123;</span><br><span class="line">    private char character;</span><br><span class="line"></span><br><span class="line">    public SharedTextCharacter(char character) &#123;</span><br><span class="line">        this.character = character;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void display(int x, int y, String color) &#123;</span><br><span class="line">        System.out.println(&quot;Displaying character: &quot; + character +</span><br><span class="line">                &quot; at position (&quot; + x + &quot;, &quot; + y + &quot;) with color &quot; + color +</span><br><span class="line">                &quot;, font: &quot; + font + &quot;, size: &quot; + size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们创建一个享元工厂类<code>TextCharacterFactory</code>，用于管理和共享文本字符对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class TextCharacterFactory &#123;</span><br><span class="line">    private Map&lt;Character, TextCharacter&gt; characterCache;</span><br><span class="line"></span><br><span class="line">    public TextCharacterFactory() &#123;</span><br><span class="line">        characterCache = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TextCharacter getCharacter(char character) &#123;</span><br><span class="line">        if (characterCache.containsKey(character)) &#123;</span><br><span class="line">            return characterCache.get(character);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            TextCharacter sharedCharacter = new SharedTextCharacter(character);</span><br><span class="line">            characterCache.put(character, sharedCharacter);</span><br><span class="line">            return sharedCharacter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们可以使用享元模式来创建和展示文本字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TextCharacterFactory characterFactory = new TextCharacterFactory();</span><br><span class="line"></span><br><span class="line">        TextCharacter characterA = characterFactory.getCharacter(&#x27;A&#x27;);</span><br><span class="line">        characterA.display(10, 20, &quot;Red&quot;);</span><br><span class="line"></span><br><span class="line">        TextCharacter characterB = characterFactory.getCharacter(&#x27;B&#x27;);</span><br><span class="line">        characterB.display(15, 25, &quot;Blue&quot;);</span><br><span class="line"></span><br><span class="line">        TextCharacter characterA2 = characterFactory.getCharacter(&#x27;A&#x27;);</span><br><span class="line">        characterA2.display(30, 40, &quot;Green&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>TextCharacterFactory</code>类用于创建和管理共享的文本字符对象。当需要获取一个字符对象时，先检查缓存中是否已经存在该对象，如果存在则直接返回，否则创建一个新的对象并存入缓存。</p>
<p>通过使用享元模式，我们可以共享相同的文本字符对象，从而减少内存占用和对象创建的开销。每个文本字符对象只包含了不可共享的外部状态，而共享的内部状态（如字符本身）则由多个对象共享。</p>
<p>总结来说，享元模式适用于需要创建大量相似对象的场景，通过共享对象的方式来减少内存消耗和对象创建的开销。它通过将共享的内部状态与非共享的外部状态分离，使得相同或相似的对象可以共享一部分状态，以达到节省内存和提高性能的目的。</p>
<h4 id="7、代理模式（Proxy-Pattern）"><a href="#7、代理模式（Proxy-Pattern）" class="headerlink" title="7、代理模式（Proxy Pattern）"></a>7、代理模式（Proxy Pattern）</h4><p>代理模式（Proxy Pattern）是一种结构型设计模式，它提供了一个代理类作为真实对象的接口，以控制对真实对象的访问。代理模式可以用于增强真实对象的功能，提供额外的操作，或者在访问真实对象之前进行验证、记录日志等操作。</p>
<p>为什么要使用代理模式呢？<br>代理模式的主要目的是控制对真实对象的访问，并提供额外的功能。在某些情况下，直接访问一个对象可能存在一些问题，例如：</p>
<ol>
<li>需要在访问真实对象之前或之后进行额外的操作，如权限验证、性能监控、缓存等；</li>
<li>需要对真实对象进行保护，只允许特定的客户端访问；</li>
<li>需要远程访问一个对象，代理模式可以将远程对象的访问细节隐藏起来。</li>
</ol>
<p>下面是一个使用代理模式的示例：假设我们正在开发一个图片加载应用程序，为了提高性能，我们希望在第一次访问图片时进行加载，然后将加载后的图片缓存在内存中，以便快速访问。我们可以使用代理模式来实现这一需求。</p>
<p>首先，定义一个抽象的图片接口<code>Image</code>，包含加载图片的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Image &#123;</span><br><span class="line">    void display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建一个具体的图片类<code>RealImage</code>，它实现了<code>Image</code>接口，并包含图片加载的具体实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RealImage</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RealImage</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filename = filename;</span><br><span class="line">        loadFromDisk();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadFromDisk</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Loading image from disk: &quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Displaying image: &quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建一个代理类<code>ImageProxy</code>，它也实现了<code>Image</code>接口，并在内部维护了一个真实图片对象的引用。在代理类中，可以在访问真实图片之前进行额外的操作，如加载图片、缓存图片等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImageProxy</span> <span class="keyword">implements</span> <span class="title class_">Image</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="keyword">private</span> RealImage realImage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ImageProxy</span><span class="params">(String filename)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.filename = filename;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (realImage == <span class="literal">null</span>) &#123;</span><br><span class="line">            realImage = <span class="keyword">new</span> <span class="title class_">RealImage</span>(filename);</span><br><span class="line">        &#125;</span><br><span class="line">        realImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们使用代理模式来加载图片并进行显示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Image</span> <span class="variable">image</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ImageProxy</span>(<span class="string">&quot;image.jpg&quot;</span>);</span><br><span class="line">        image.display();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 图片已经加载过，再次显示时不会重新加载</span></span><br><span class="line">        image.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，<code>ImageProxy</code>类充当了代理类的角色。当第一次调用<code>display()</code>方法时，代理类会创建一个真实图片对象<code>RealImage</code>并进行加载。当再次调用<code>display()</code>方法时，代理类会直接使用已经加载过的图片对象进行显示，从而提高了性能。</p>
<p>通过使用代理模式，我们可以控制对真实图片对象的访问，并在访问前后进行额外的操作，例如加载图片、缓存图片等。代理模式使得真实对象的访问更加灵活和可控。</p>
<p>总结来说，代理模式被用于控制对真实对象的访问，并提供额外的功能。它可以用于实现对真实对象访问的控制、增加额外的操作或保护真实对象。在使用代理模式时，我们需要定义一个代理类，它实现了与真实对象相同的接口，并在对真实对象的访问中进行必要的控制和操作。</p>
<h2 id="三、行为型模式（Behavioral-Patterns）"><a href="#三、行为型模式（Behavioral-Patterns）" class="headerlink" title="三、行为型模式（Behavioral Patterns）:"></a>三、行为型模式（Behavioral Patterns）:</h2><p>这些模式用于处理对象之间的相互作用，定义了不同对象之间的通信和协作方式</p>
<h4 id="1、责任链模式（Chain-of-Responsibility-Pattern）"><a href="#1、责任链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="1、责任链模式（Chain of Responsibility Pattern）"></a>1、责任链模式（Chain of Responsibility Pattern）</h4><p>责任链模式（Chain of Responsibility Pattern）是一种行为型设计模式，它将请求的发送者和接收者解耦，使多个对象都有机会处理该请求。责任链模式形成一个链式结构，每个处理器对象都可以决定是否处理该请求，将请求传递给下一个处理器，直到找到合适的处理器处理请求。</p>
<p>为什么要使用责任链模式呢？<br>责任链模式的主要目的是将请求的发送者和接收者解耦，并提供一种灵活的处理方式。当有多个对象可以处理同一个请求时，此模式可以避免将请求的发送者与接收者紧密耦合在一起，而是将它们解耦，并通过责任链动态决定由哪个对象来处理请求。这样的设计可以提高代码的灵活性和可扩展性。</p>
<p>下面是一个使用责任链模式的示例：假设我们正在开发一个在线购物系统，当用户下单时，需要依次经过库存检查、优惠券验证和支付处理。如果库存不足，则无法下单；如果优惠券验证失败，则不能享受优惠；如果支付失败，则订单无法完成。我们可以使用责任链模式来处理这一系列的操作。</p>
<p>首先，定义一个抽象处理器接口<code>OrderHandler</code>，它包含处理请求的方法和设置下一个处理器的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public abstract class OrderHandler &#123;</span><br><span class="line">    protected OrderHandler nextHandler;</span><br><span class="line"></span><br><span class="line">    public void setNextHandler(OrderHandler nextHandler) &#123;</span><br><span class="line">        this.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public abstract void handleOrder(Order order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建具体的处理器类，这里以库存检查、优惠券验证和支付处理为例。每个处理器类都实现了<code>OrderHandler</code>接口，并在<code>handleOrder()</code>方法中处理请求，如果无法处理请求，则将请求传递给下一个处理器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class StockCheckHandler extends OrderHandler &#123;</span><br><span class="line">    public void handleOrder(Order order) &#123;</span><br><span class="line">        if (checkStock(order)) &#123;</span><br><span class="line">            System.out.println(&quot;Stock check passed. Processing next...&quot;);</span><br><span class="line">            if (nextHandler != null) &#123;</span><br><span class="line">                nextHandler.handleOrder(order);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Stock check failed. Order cannot be processed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean checkStock(Order order) &#123;</span><br><span class="line">        // Perform stock check logic here</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CouponValidationHandler extends OrderHandler &#123;</span><br><span class="line">    public void handleOrder(Order order) &#123;</span><br><span class="line">        if (validateCoupon(order)) &#123;</span><br><span class="line">            System.out.println(&quot;Coupon validation passed. Processing next...&quot;);</span><br><span class="line">            if (nextHandler != null) &#123;</span><br><span class="line">                nextHandler.handleOrder(order);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Coupon validation failed. Order cannot be processed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean validateCoupon(Order order) &#123;</span><br><span class="line">        // Perform coupon validation logic here</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class PaymentProcessingHandler extends OrderHandler &#123;</span><br><span class="line">    public void handleOrder(Order order) &#123;</span><br><span class="line">        if (processPayment(order)) &#123;</span><br><span class="line">            System.out.println(&quot;Payment processed successfully.&quot;);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(&quot;Payment processing failed. Order cannot be processed.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean processPayment(Order order) &#123;</span><br><span class="line">        // Perform payment processing logic here</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们使用责任链模式来处理订单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        OrderHandler stockCheckHandler = new StockCheckHandler();</span><br><span class="line">        OrderHandler couponValidationHandler = new CouponValidationHandler();</span><br><span class="line">        OrderHandler paymentProcessingHandler = new PaymentProcessingHandler();</span><br><span class="line"></span><br><span class="line">        stockCheckHandler.setNextHandler(couponValidationHandler);</span><br><span class="line">        couponValidationHandler.setNextHandler(paymentProcessingHandler);</span><br><span class="line"></span><br><span class="line">        Order order = new Order();</span><br><span class="line">        stockCheckHandler.handleOrder(order);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们创建了三个具体的处理器类：<code>StockCheckHandler</code>、<code>CouponValidationHandler</code>和<code>PaymentProcessingHandler</code>。每个处理器类都有自己的处理逻辑，并在适当的情况下将请求传递给下一个处理器。最后，我们创建了一个责任链，将处理器按照处理顺序连接起来。当调用<code>stockCheckHandler.handleOrder(order)</code>时，责任链将依次处理请求，并输出相应的处理结果。</p>
<p>通过使用责任链模式，我们实现了将请求的发送者和接收者解耦，并提供了一种动态决定最终处理者的方式。每个处理器都可以选择处理请求，传递请求给下一个处理器或终止处理链。这种设计可以灵活地增加、修改或重排处理器，从而满足不同的业务需求。</p>
<p>总结来说，责任链模式被用于将请求的发送者和接收者解耦，并提供一种灵活的处理方式。在使用责任链模式时，我们定义一个抽象的处理器接口和具体的处理器类，将它们组织成责任链，并在处理器内部决定是否处理请求，以及是否将请求传递给下一个处理器。</p>
<h4 id="2、命令模式（Command-Pattern）"><a href="#2、命令模式（Command-Pattern）" class="headerlink" title="2、命令模式（Command Pattern）"></a>2、命令模式（Command Pattern）</h4><p>命令模式（Command Pattern）是一种行为型设计模式，它将请求封装成一个对象，从而使得请求的发送者和接收者可以解耦。命令模式允许将请求参数化，将请求交给不同的对象进行处理，并支持撤销操作。</p>
<p>命令模式由以下几个角色组成：</p>
<ol>
<li>Command（命令）：定义了执行请求的接口。</li>
<li>ConcreteCommand（具体命令）：实现了Command接口，对请求进行具体的处理。</li>
<li>Invoker（调用者）：负责调用命令对象执行请求。</li>
<li>Receiver（接收者）：执行命令所指定的操作。</li>
<li>Client（客户端）：创建命令对象，并设置其接收者。</li>
</ol>
<p>为什么要使用命令模式呢？<br>命令模式的主要目的是实现请求的发送者和接收者的解耦。通过将请求封装成一个对象，我们可以灵活地指定请求的接收者，并可以对请求进行参数化和操作的撤销。</p>
<p>下面是一个使用命令模式的示例：假设我们正在开发一个遥控器程序，可以通过遥控器发送不同的命令来控制电灯的开关。我们可以使用命令模式来实现这个功能。</p>
<p>首先，定义命令接口<code>Command</code>，它包含执行命令和撤销命令的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Command &#123;</span><br><span class="line">    void execute();</span><br><span class="line">    void undo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建具体的命令类，这里以开灯命令和关灯命令为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class LightOnCommand implements Command &#123;</span><br><span class="line">    private Light light;</span><br><span class="line"></span><br><span class="line">    public LightOnCommand(Light light) &#123;</span><br><span class="line">        this.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        light.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void undo() &#123;</span><br><span class="line">        light.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class LightOffCommand implements Command &#123;</span><br><span class="line">    private Light light;</span><br><span class="line"></span><br><span class="line">    public LightOffCommand(Light light) &#123;</span><br><span class="line">        this.light = light;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void execute() &#123;</span><br><span class="line">        light.turnOff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void undo() &#123;</span><br><span class="line">        light.turnOn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建接收者类<code>Light</code>，它包含了实际的操作逻辑：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Light &#123;</span><br><span class="line">    public void turnOn() &#123;</span><br><span class="line">        System.out.println(&quot;Light is on&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void turnOff() &#123;</span><br><span class="line">        System.out.println(&quot;Light is off&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建调用者类<code>RemoteControl</code>，它负责接收命令并执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class RemoteControl &#123;</span><br><span class="line">    private Command command;</span><br><span class="line"></span><br><span class="line">    public void setCommand(Command command) &#123;</span><br><span class="line">        this.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pressButton() &#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void pressUndo() &#123;</span><br><span class="line">        command.undo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在客户端中创建命令对象并设置接收者，然后将命令对象传递给遥控器进行控制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 创建接收者</span><br><span class="line">        Light light = new Light();</span><br><span class="line"></span><br><span class="line">        // 创建命令对象并设置接收者</span><br><span class="line">        Command lightOnCommand = new LightOnCommand(light);</span><br><span class="line">        Command lightOffCommand = new LightOffCommand(light);</span><br><span class="line"></span><br><span class="line">        // 创建调用者</span><br><span class="line">        RemoteControl remoteControl = new RemoteControl();</span><br><span class="line"></span><br><span class="line">        // 设置命令对象</span><br><span class="line">        remoteControl.setCommand(lightOnCommand);</span><br><span class="line"></span><br><span class="line">        // 执行命令</span><br><span class="line">        remoteControl.pressButton();</span><br><span class="line"></span><br><span class="line">        // 撤销命令</span><br><span class="line">        remoteControl.pressUndo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了命令接口<code>Command</code>和具体的命令类<code>LightOnCommand</code>和<code>LightOffCommand</code>，它们实现了<code>Command</code>接口并封装了对接收者<code>Light</code>的操作。我们还创建了调用者类<code>RemoteControl</code>，它负责接收命令并执行。最后，在客户端中，我们创建了命令对象并设置了接收者，然后将命令对象传递给遥控器进行控制。</p>
<p>通过使用命令模式，我们实现了请求的发送者和接收者的解耦，并支持了参数化和撤销操作。每个命令对象都封装了一个请求，并通过调用命令对象的<code>execute()</code>方法来执行请求。调用者只需要关心将命令对象与接收者进行关联，并调用命令对象的方法即可。这样的设计可以提高代码的灵活性和可维护性，同时支持新增命令、修改命令和撤销命令的操作。</p>
<p>总结来说，命令模式被用于将请求封装成一个对象，从而实现请求的发送者和接收者的解耦。通过使用命令模式，我们可以灵活地指定请求的接收者，并支持参数化和操作的撤销。在使用命令模式时，我们定义一个命令接口和具体的命令类，将命令对象与接收者关联，并由调用者来执行命令</p>
<h4 id="3、解释器模式（Interpreter-Pattern）"><a href="#3、解释器模式（Interpreter-Pattern）" class="headerlink" title="3、解释器模式（Interpreter Pattern）"></a>3、解释器模式（Interpreter Pattern）</h4><p>解释器模式（Interpreter Pattern）是一种行为型设计模式，它用于解决一些简单的语言解释器的设计问题。解释器模式定义了一个语言的文法，并定义了解释该语言中语句的解释器。通过使用解释器模式，我们可以实现一个简单的解释器，用来解释和执行特定的语言表达式。</p>
<p>解释器模式由以下几个角色组成：</p>
<ol>
<li>AbstractExpression（抽象表达式）：定义解释器的接口，声明了解释器的解释方法。</li>
<li>TerminalExpression（终结符表达式）：继承自抽象表达式，实现了解释器的解释方法。终结符表达式表示语言中的基本单元，不再包含其他表达式。</li>
<li>NonterminalExpression（非终结符表达式）：继承自抽象表达式，实现了解释器的解释方法。非终结符表达式由终结符表达式和其他非终结符表达式组成。</li>
<li>Context（上下文）：包含解释器的全局信息，供解释器使用。</li>
</ol>
<p>为什么要使用解释器模式呢？<br>解释器模式主要用于解决一些简单的语言解释器的问题。当我们需要设计一个简单的语言或处理类似于正则表达式或查询语言的解析和执行时，解释器模式就很有用了。它允许我们通过定义语言的文法和相应的解释器来解释和执行语句，使得代码的扩展和维护更加方便。</p>
<p>现在，让我们通过一个简单的例子来演示解释器模式的用法。假设我们要设计一个语言，可以解析并计算简单的数学表达式，支持加法和乘法操作。我们可以使用解释器模式来实现这个语言的解释器。</p>
<p>首先，定义抽象表达式<code>Expression</code>，其中包含了解释器的解释方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Expression &#123;</span><br><span class="line">    int interpret(Context context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建终结符表达式<code>NumberExpression</code>和非终结符表达式<code>AddExpression</code>和<code>MultiplyExpression</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class NumberExpression implements Expression &#123;</span><br><span class="line">    private int number;</span><br><span class="line"></span><br><span class="line">    public NumberExpression(int number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    public int interpret(Context context) &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AddExpression implements Expression &#123;</span><br><span class="line">    private Expression left;</span><br><span class="line">    private Expression right;</span><br><span class="line"></span><br><span class="line">    public AddExpression(Expression left, Expression right) &#123;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int interpret(Context context) &#123;</span><br><span class="line">        return left.interpret(context) + right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MultiplyExpression implements Expression &#123;</span><br><span class="line">    private Expression left;</span><br><span class="line">    private Expression right;</span><br><span class="line"></span><br><span class="line">    public MultiplyExpression(Expression left, Expression right) &#123;</span><br><span class="line">        this.left = left;</span><br><span class="line">        this.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int interpret(Context context) &#123;</span><br><span class="line">        return left.interpret(context) * right.interpret(context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，创建上下文类<code>Context</code>，用于存储解释器的全局信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Context &#123;</span><br><span class="line">    private Map&lt;String, Integer&gt; variables;</span><br><span class="line"></span><br><span class="line">    public Context() &#123;</span><br><span class="line">        variables = new HashMap&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setVariable(String name, int value) &#123;</span><br><span class="line">        variables.put(name, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getVariable(String name) &#123;</span><br><span class="line">        return variables.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，在客户端中创建上下文对象，解析并计算表达式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Context context = new Context();</span><br><span class="line">        context.setVariable(&quot;a&quot;, 5);</span><br><span class="line">        context.setVariable(&quot;b&quot;, 3);</span><br><span class="line"></span><br><span class="line">        Expression expression = new MultiplyExpression(</span><br><span class="line">            new AddExpression(new NumberExpression(2), new NumberExpression(3)),</span><br><span class="line">            new NumberExpression(4));</span><br><span class="line"></span><br><span class="line">        int result = expression.interpret(context);</span><br><span class="line">        System.out.println(&quot;Result: &quot; + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了抽象表达式<code>Expression</code>和具体的表达式类<code>NumberExpression</code>、<code>AddExpression</code>和<code>MultiplyExpression</code>，它们分别表示数字表达式、加法表达式和乘法表达式。我们还创建了上下文类<code>Context</code>，用于存储解释器的全局信息。在客户端中，我们创建了上下文对象并设置了变量的值，然后创建了一个复杂的数学表达式，并通过解释器模式解释和计算了表达式的结果。</p>
<p>通过使用解释器模式，我们可以将复杂的语言表达式分解成简单的终结符表达式和非终结符表达式，并通过解释器来解释和计算表达式。这种设计方式使得表达式的解析和执行的逻辑分离，提高了代码的可维护性和灵活性。解释器模式可以应用于各种领域，例如编译器、正则表达式引擎等。</p>
<p>总结来说，解释器模式用于解决一些简单的语言解释器的设计问题。它定义了解释器的接口和具体的解释器类，通过组合不同的表达式来解释和执行语句。通过使用解释器模式，我们可以定义和执行自定义的语言，实现其解析和执行逻辑</p>
<h4 id="4、迭代器模式（Iterator-Pattern）"><a href="#4、迭代器模式（Iterator-Pattern）" class="headerlink" title="4、迭代器模式（Iterator Pattern）"></a>4、迭代器模式（Iterator Pattern）</h4><p>迭代器模式（Iterator Pattern）是一种行为型设计模式，它提供了一种遍历容器对象元素的方法，而无需暴露容器的内部结构。通过迭代器模式，我们可以按顺序访问一个容器对象中的元素，而无需关心容器的具体实现方式。</p>
<p>迭代器模式由以下几个角色组成：</p>
<ol>
<li>Iterator（迭代器）：定义了访问和遍历元素的接口，包括获取下一个元素、判断是否还有下一个元素等方法。</li>
<li>ConcreteIterator（具体迭代器）：实现了迭代器接口，在具体容器对象中实现了对元素的遍历。</li>
<li>Aggregate（容器）：定义了创建迭代器对象的接口，通常包括获取迭代器和添加元素的方法。</li>
<li>ConcreteAggregate（具体容器）：实现了容器接口，创建具体迭代器对象，存储元素并提供访问元素的方法。</li>
</ol>
<p>为什么要使用迭代器模式呢？<br>迭代器模式主要用于解决遍历容器对象的问题，它将遍历逻辑封装在迭代器中，使得容器的结构可以独立于遍历算法改变。通过使用迭代器模式，我们可以以统一的方式遍历不同类型的容器对象，提高代码的可复用性和可维护性。</p>
<p>现在，让我们通过一个具体的例子来演示迭代器模式的用法。假设我们要创建一个简单的音乐播放器，其中有一个音乐库用于存储音乐曲目。我们可以使用迭代器模式来遍历音乐库中的曲目。</p>
<p>首先，定义迭代器接口<code>Iterator</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;T&gt; &#123;</span><br><span class="line">    boolean hasNext();</span><br><span class="line">    T next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建具体迭代器类<code>MusicIterator</code>实现迭代器接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MusicIterator implements Iterator&lt;String&gt; &#123;</span><br><span class="line">    private List&lt;String&gt; tracks;</span><br><span class="line">    private int position;</span><br><span class="line"></span><br><span class="line">    public MusicIterator(List&lt;String&gt; tracks) &#123;</span><br><span class="line">        this.tracks = tracks;</span><br><span class="line">        this.position = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return position &lt; tracks.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String next() &#123;</span><br><span class="line">        if (hasNext()) &#123;</span><br><span class="line">            String track = tracks.get(position);</span><br><span class="line">            position++;</span><br><span class="line">            return track;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，定义容器接口<code>MusicCollection</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface MusicCollection &#123;</span><br><span class="line">    Iterator&lt;String&gt; createIterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体容器类<code>Playlist</code>实现容器接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Playlist implements MusicCollection &#123;</span><br><span class="line">    private List&lt;String&gt; tracks;</span><br><span class="line"></span><br><span class="line">    public Playlist() &#123;</span><br><span class="line">        this.tracks = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addTrack(String track) &#123;</span><br><span class="line">        tracks.add(track);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Iterator&lt;String&gt; createIterator() &#123;</span><br><span class="line">        return new MusicIterator(tracks);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端代码中，我们可以使用迭代器来遍历音乐库中的曲目：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Playlist playlist = new Playlist();</span><br><span class="line">        playlist.addTrack(&quot;Track 1&quot;);</span><br><span class="line">        playlist.addTrack(&quot;Track 2&quot;);</span><br><span class="line">        playlist.addTrack(&quot;Track 3&quot;);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = playlist.createIterator();</span><br><span class="line"></span><br><span class="line">        while (iterator.hasNext()) &#123;</span><br><span class="line">            String track = iterator.next();</span><br><span class="line">            System.out.println(&quot;Playing: &quot; + track);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了迭代器接口<code>Iterator</code>和具体迭代器类<code>MusicIterator</code>，它们用于遍历音乐库中的曲目。我们还定义了容器接口<code>MusicCollection</code>和具体容器类<code>Playlist</code>，用于存储音乐曲目并创建对应的迭代器。在客户端代码中，我们创建了一个音乐播放列表并添加了曲目，然后使用迭代器来遍历并播放曲目。</p>
<p>通过使用迭代器模式，我们将遍历容器对象的逻辑封装在迭代器中，使得容器的结构可以独立于遍历算法改变。这种设计方式提高了代码的灵活性和可维护性。迭代器模式广泛应用于各种编程场景，例如集合类、文件系统等。</p>
<p>总结来说，迭代器模式用于遍历容器对象的元素，提供一种统一的方式访问容器的元素，而不必暴露容器的内部结构。它由迭代器、具体迭代器、容器和具体容器等组成。迭代器模式通过封装遍历逻辑，使得遍历算法可以独立于容器改变，提高了代码的可复用性和可维护性。</p>
<h4 id="5、中介者模式（Mediator-Pattern）"><a href="#5、中介者模式（Mediator-Pattern）" class="headerlink" title="5、中介者模式（Mediator Pattern）"></a>5、中介者模式（Mediator Pattern）</h4><p>中介者模式（Mediator Pattern）是一种行为型设计模式，它用于将对象之间的交互行为封装到一个中介者对象中，使得对象之间的通信通过中介者进行，而不是直接相互调用。这样可以降低对象之间的耦合性，促进对象之间的松耦合。</p>
<p>中介者模式由以下几个角色组成：</p>
<ol>
<li>Mediator（中介者）：定义了各个对象之间的交互接口，通常包括注册对象、发送消息、获取消息等方法。</li>
<li>ConcreteMediator（具体中介者）：实现了中介者接口，具体实现对象之间的交互逻辑，维护一个对象列表用于管理对象间的通信。</li>
<li>Colleague（同事类）：定义了对象的行为接口，中介者和对象之间通信的目标。</li>
<li>ConcreteColleague（具体同事类）：实现了同事类接口，每个具体同事类都需通过中介者来与其他对象进行通信。</li>
</ol>
<p>为什么要使用中介者模式呢？<br>在复杂系统中，对象之间的直接通信会造成高耦合，难以维护和扩展。通过引入中介者模式，我们可以将对象之间的交互逻辑抽离出来，集中在中介者对象中管理。这样，对象只需要与中介者进行通信，而无需了解其他对象的具体实现细节，从而降低了对象之间的耦合性。</p>
<p>现在，让我们通过一个具体的例子来演示中介者模式的用法。假设我们正在构建一个简单的聊天室应用程序，其中有多个用户对象可以发送和接收消息。我们可以使用中介者模式来实现用户之间的通信。</p>
<p>首先，定义中介者接口<code>ChatMediator</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface ChatMediator &#123;</span><br><span class="line">    void sendMessage(User user, String message);</span><br><span class="line">    void addUser(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建具体中介者类<code>ChatRoom</code>实现中介者接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class ChatRoom implements ChatMediator &#123;</span><br><span class="line">    private List&lt;User&gt; users;</span><br><span class="line"></span><br><span class="line">    public ChatRoom() &#123;</span><br><span class="line">        this.users = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(User user, String message) &#123;</span><br><span class="line">        for (User u : users) &#123;</span><br><span class="line">            if (u != user) &#123;</span><br><span class="line">                u.receiveMessage(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void addUser(User user) &#123;</span><br><span class="line">        users.add(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，定义同事类接口<code>User</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface User &#123;</span><br><span class="line">    void sendMessage(String message);</span><br><span class="line">    void receiveMessage(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建具体同事类<code>UserImpl</code>实现同事类接口：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class UserImpl implements User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private ChatMediator chatMediator;</span><br><span class="line"></span><br><span class="line">    public UserImpl(String name, ChatMediator chatMediator) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.chatMediator = chatMediator;</span><br><span class="line">        chatMediator.addUser(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sendMessage(String message) &#123;</span><br><span class="line">        chatMediator.sendMessage(this, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void receiveMessage(String message) &#123;</span><br><span class="line">        System.out.println(name + &quot; received message: &quot; + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>在客户端代码中，我们可以创建多个用户对象并让它们通过中介者进行通信：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ChatMediator chatMediator = new ChatRoom();</span><br><span class="line"></span><br><span class="line">        User user1 = new UserImpl(&quot;User1&quot;, chatMediator);</span><br><span class="line">        User user2 = new UserImpl(&quot;User2&quot;, chatMediator);</span><br><span class="line">        User user3 = new UserImpl(&quot;User3&quot;, chatMediator);</span><br><span class="line"></span><br><span class="line">        user1.sendMessage(&quot;Hello, everyone!&quot;);</span><br><span class="line">        user2.sendMessage(&quot;Hi there!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了中介者接口<code>ChatMediator</code>和具体中介者类<code>ChatRoom</code>，它们用于管理用户之间的通信。我们还定义了同事类接口<code>User</code>和具体同事类<code>UserImpl</code>，用于表示聊天室中的用户。在客户端代码中，我们创建了一个聊天室中介者对象和多个用户对象，并让用户对象通过中介者进行通信。</p>
<p>通过使用中介者模式，我们将对象之间的通信逻辑封装在中介者对象中，使得对象可以通过中介者进行通信，而无需直接相互调用。这种设计方式降低了对象之间的耦合性，提高了代码的可维护性和可扩展性。中介者模式常用于复杂的对象间交互场景，如聊天室、GUI组件等。</p>
<p>总结来说，中介者模式将对象之间的通信行为封装到中介者对象中，通过中介者来协调对象之间的交互。它由中介者、具体中介者、同事类和具体同事类等组成。中介者模式能够降低对象之间的耦合性，提高代码的可维护性和可扩展性</p>
<h4 id="6、备忘录模式（Memento-Pattern）"><a href="#6、备忘录模式（Memento-Pattern）" class="headerlink" title="6、备忘录模式（Memento Pattern）"></a>6、备忘录模式（Memento Pattern）</h4><p>备忘录模式（Memento Pattern）是一种行为型设计模式，用于捕获和存储对象的内部状态，以便在需要时可以恢复到先前的状态。它通过将对象的状态封装到备忘录对象中，实现了对象状态的保存和恢复，同时保持了对象的封装性。</p>
<p>备忘录模式的主要角色包括：</p>
<ul>
<li>Originator（原发器）：负责创建备忘录对象，并可以使用备忘录对象恢复其内部状态。</li>
<li>Memento（备忘录）：用于存储原发器对象的内部状态，可以防止原发器之外的其他对象访问备忘录。</li>
<li>Caretaker（负责人）：负责保存和管理备忘录对象，可以对备忘录进行存储和恢复操作。</li>
</ul>
<p>为什么要使用备忘录模式呢？<br>在某些情况下，需要实现对象的状态保存和恢复，例如在撤销操作或者事务回滚中。使用备忘录模式可以将对象的状态封装到备忘录对象中，使得可以方便地保存和恢复对象的状态，而不需要暴露对象的实现细节。</p>
<p>现在，让我们通过一个具体的例子来演示备忘录模式的用法。假设我们正在开发一个文本编辑器应用程序，用户可以输入文本并进行编辑操作，我们希望能够实现撤销操作，即撤销上一步的编辑。</p>
<p>首先，定义备忘录类<code>EditorMemento</code>，用于存储编辑器的状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class EditorMemento &#123;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    public EditorMemento(String content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，定义原发器类<code>TextEditor</code>，负责创建和恢复备忘录对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class TextEditor &#123;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EditorMemento save() &#123;</span><br><span class="line">        return new EditorMemento(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void restore(EditorMemento memento) &#123;</span><br><span class="line">        this.content = memento.getContent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，定义负责人类<code>History</code>，用于保存和管理备忘录对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class History &#123;</span><br><span class="line">    private Stack&lt;EditorMemento&gt; mementos;</span><br><span class="line"></span><br><span class="line">    public History() &#123;</span><br><span class="line">        mementos = new Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void push(EditorMemento memento) &#123;</span><br><span class="line">        mementos.push(memento);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EditorMemento pop() &#123;</span><br><span class="line">        return mementos.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端代码中，我们可以创建文本编辑器对象并进行编辑操作，同时使用负责人对象来保存和管理备忘录对象，以便进行撤销操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        TextEditor textEditor = new TextEditor();</span><br><span class="line">        History history = new History();</span><br><span class="line"></span><br><span class="line">        textEditor.setContent(&quot;Initial content&quot;);</span><br><span class="line">        history.push(textEditor.save());</span><br><span class="line"></span><br><span class="line">        textEditor.setContent(&quot;Updated content&quot;);</span><br><span class="line">        history.push(textEditor.save());</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Current content: &quot; + textEditor.getContent());</span><br><span class="line"></span><br><span class="line">        textEditor.restore(history.pop());</span><br><span class="line">        System.out.println(&quot;Restored content: &quot; + textEditor.getContent());</span><br><span class="line"></span><br><span class="line">        textEditor.restore(history.pop());</span><br><span class="line">        System.out.println(&quot;Restored content: &quot; + textEditor.getContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了备忘录类<code>EditorMemento</code>用于存储编辑器的状态。原发器类<code>TextEditor</code>负责创建备忘录对象<code>save()</code>并将其状态存储在备忘录对象中，同时可以通过<code>restore()</code>方法将状态恢复到先前的状态。负责人类<code>History</code>使用堆栈数据结构保存备忘录对象，可以通过<code>push()</code>保存备忘录对象，通过<code>pop()</code>获取最近保存的备忘录对象。</p>
<p>在客户端代码中，我们创建了一个文本编辑器对象<code>textEditor</code>和一个负责人对象<code>history</code>，并进行了一系列编辑操作。通过调用<code>save()</code>方法将当前编辑器状态保存到备忘录对象中，并使用<code>push()</code>方法将备忘录对象保存到负责人对象中。当需要撤销时，可以通过<code>pop()</code>方法获取最近保存的备忘录对象，并使用<code>restore()</code>方法将编辑器的状态恢复到该备忘录所代表的状态。</p>
<p>通过使用备忘录模式，我们可以实现对象状态的保存和恢复，实现撤销操作或者事务回滚。备忘录模式的核心思想是将对象的状态封装到备忘录对象中，使得对象的状态可以被保存和恢复，同时保持了对象的封装性和高内聚性。</p>
<p>总结来说，备忘录模式通过使用备忘录、原发器和负责人等角色，实现了对象状态的保存和恢复。备忘录模式的优点是可以方便地实现撤销操作或者事务回滚，同时保持了对象的封装性。它常用于需要保存和恢复对象状态的场景，如编辑器、文档编辑、事务管理等。</p>
<h4 id="7、观察者模式（Observer-Pattern）"><a href="#7、观察者模式（Observer-Pattern）" class="headerlink" title="7、观察者模式（Observer Pattern）"></a>7、观察者模式（Observer Pattern）</h4><p>观察者模式（Observer Pattern）是一种行为型设计模式，它定义了一种一对多的依赖关系，当一个对象的状态发生变化时，它所有依赖它的对象都会得到通知并自动更新。</p>
<p>观察者模式的主要角色包括：</p>
<ul>
<li>Subject（主题）：被观察对象，它包含了一组观察者对象，并提供了添加、删除和通知观察者的方法。</li>
<li>Observer（观察者）：观察主题的对象，在主题发生变化时，观察者会自动收到通知并进行相应的更新操作。</li>
</ul>
<p>为什么要使用观察者模式呢？<br>观察者模式可以实现对象间的松耦合，使得主题和观察者之间的关系解耦。当一个对象的状态发生变化时，它无需关心具体有哪些对象对其感兴趣，只需要通知注册的观察者对象即可。这样可以降低对象之间的耦合性，提高系统的灵活性和可维护性。</p>
<p>现在，让我们通过一个具体的例子来演示观察者模式的用法。假设我们正在开发一个气象站应用程序，该应用程序可以实时获取温度、湿度和气压等气象数据，并将数据展示给用户和记录日志。我们希望实现一个观察者模式来让用户界面和日志记录模块自动更新数据。</p>
<p>首先，定义主题接口<code>Subject</code>，其中包含了添加、删除和通知观察者的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public interface Subject &#123;</span><br><span class="line">    void addObserver(Observer observer);</span><br><span class="line">    void removeObserver(Observer observer);</span><br><span class="line">    void notifyObservers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，定义观察者接口<code>Observer</code>，其中包含了接收和处理数据更新的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Observer &#123;</span><br><span class="line">    void update(float temperature, float humidity, float pressure);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，定义具体主题类<code>WeatherStation</code>，实现主题接口，并在状态发生变化时通知观察者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class WeatherStation implements Subject &#123;</span><br><span class="line">    private List&lt;Observer&gt; observers;</span><br><span class="line">    private float temperature;</span><br><span class="line">    private float humidity;</span><br><span class="line">    private float pressure;</span><br><span class="line"></span><br><span class="line">    public WeatherStation() &#123;</span><br><span class="line">        observers = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void setWeatherData(float temperature, float humidity, float pressure) &#123;</span><br><span class="line">        this.temperature = temperature;</span><br><span class="line">        this.humidity = humidity;</span><br><span class="line">        this.pressure = pressure;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addObserver(Observer observer) &#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void removeObserver(Observer observer) &#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void notifyObservers() &#123;</span><br><span class="line">        for (Observer observer : observers) &#123;</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，定义具体观察者类<code>UserInterface</code>和<code>Logger</code>，实现观察者接口，并在接收到通知时进行相应的更新操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserInterface</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;User Interface: Temperature = &quot;</span> + temperature + <span class="string">&quot;, Humidity = &quot;</span> + humidity + <span class="string">&quot;, Pressure = &quot;</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Logger</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">float</span> temperature, <span class="type">float</span> humidity, <span class="type">float</span> pressure)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Logger: Temperature = &quot;</span> + temperature + <span class="string">&quot;, Humidity = &quot;</span> + humidity + <span class="string">&quot;, Pressure = &quot;</span> + pressure);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端代码中，我们可以创建主题对象<code>weatherStation</code>和观察者对象<code>userInterface</code>、<code>logger</code>，并进行注册和更新操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WeatherStation</span> <span class="variable">weatherStation</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeatherStation</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Observer</span> <span class="variable">userInterface</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserInterface</span>();</span><br><span class="line">        <span class="type">Observer</span> <span class="variable">logger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Logger</span>();</span><br><span class="line"></span><br><span class="line">        weatherStation.addObserver(userInterface);</span><br><span class="line">        weatherStation.addObserver(logger);</span><br><span class="line"></span><br><span class="line">        weatherStation.setWeatherData(<span class="number">25.5f</span>, <span class="number">60f</span>, <span class="number">1013.25f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了主题接口<code>Subject</code>和观察者接口<code>Observer</code>，并实现了具体的主题类<code>WeatherStation</code>和观察者类<code>UserInterface</code>、<code>Logger</code>。在客户端代码中，我们创建了一个主题实例<code>weatherStation</code>，以及观察者实例<code>userInterface</code>和<code>logger</code>。然后，通过调用<code>addObserver()</code>方法将观察者注册到主题中。当调用<code>setWeatherData()</code>方法更新天气数据时，主题会自动通知观察者，并调用其对应的<code>update()</code>方法进行更新操作。</p>
<p>通过使用观察者模式，我们实现了一种松耦合的对象间通信机制。主题和观察者之间的关系解耦，主题只需关注如何通知观察者，不需知道具体观察者的实现细节。观察者可以方便地注册、注销和接收通知，实现了对象间的动态交互。</p>
<p>总结来说，观察者模式通过定义主题和观察者之间的一对多依赖关系，将对象间的关系解耦，实现了对象的松耦合性和高内聚性。观察者模式的优点是方便扩展和维护，能够实现动态的发布-订阅机制。它常用于GUI界面、事件处理、消息队列等场景，为多个对象之间的通信提供了一种灵活的解决方案。</p>
<h4 id="8、状态模式（State-Pattern）"><a href="#8、状态模式（State-Pattern）" class="headerlink" title="8、状态模式（State Pattern）"></a>8、状态模式（State Pattern）</h4><p>状态模式（State Pattern）是一种行为型设计模式，它允许一个对象在内部状态改变时改变其行为，看起来好像是改变了对象的类。状态模式将对象的行为封装在不同的状态类中，使得对象在不同的状态下表现出不同的行为。</p>
<p>状态模式的主要角色包括：</p>
<ul>
<li>Context（环境）：定义客户端所感兴趣的接口，并且维护一个具体状态类的实例，用于处理状态的转换。</li>
<li>State（状态）：定义一个接口，封装了与Context的特定状态相关的行为。</li>
<li>ConcreteState（具体状态）：实现State接口的具体状态类，处理与特定状态相关的行为。</li>
</ul>
<p>为什么要使用状态模式呢？<br>在某些情况下，一个对象的行为会随着其内部状态的变化而变化，如果直接在对象中编写大量的if-else或switch语句用于判断不同的状态并执行对应的操作，会导致代码变得冗长、复杂且难以维护。而使用状态模式可以将每个状态的行为封装到具体状态类中，使得代码结构清晰、可扩展性强，并且能够方便地增加新的状态和对应的行为。</p>
<p>现在，让我们通过一个具体的例子来演示状态模式的用法。假设我们正在开发一个文档编辑器应用程序，该应用程序可以根据当前的编辑状态（例如，选择状态、插入文本状态、删除文本状态等）来决定用户的操作行为。</p>
<p>首先，定义上下文类<code>Editor</code>，它维护一个对当前状态的引用，并提供方法用于改变当前状态和委托执行具体的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Editor &#123;</span><br><span class="line">    private State currentState;</span><br><span class="line"></span><br><span class="line">    public Editor() &#123;</span><br><span class="line">        currentState = new DefaultState(); // 设置默认状态</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setState(State state) &#123;</span><br><span class="line">        currentState = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void click() &#123;</span><br><span class="line">        currentState.click(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void doubleClick() &#123;</span><br><span class="line">        currentState.doubleClick(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其他操作方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，定义状态接口<code>State</code>，其中定义了不同状态下的操作方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface State &#123;</span><br><span class="line">    void click(Editor editor);</span><br><span class="line"></span><br><span class="line">    void doubleClick(Editor editor);</span><br><span class="line"></span><br><span class="line">    // 其他操作方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，定义具体状态类，例如选择状态<code>SelectionState</code>和插入文本状态<code>InsertTextState</code>，实现对应的操作方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class SelectionState implements State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void click(Editor editor) &#123;</span><br><span class="line">        System.out.println(&quot;Deselect the selected text.&quot;);</span><br><span class="line">        editor.setState(new DefaultState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doubleClick(Editor editor) &#123;</span><br><span class="line">        System.out.println(&quot;Select the word.&quot;);</span><br><span class="line">        // 保持当前状态不变</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其他操作方法...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class InsertTextState implements State &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void click(Editor editor) &#123;</span><br><span class="line">        System.out.println(&quot;Insert text at the clicked position.&quot;);</span><br><span class="line">        // 保持当前状态不变</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void doubleClick(Editor editor) &#123;</span><br><span class="line">        System.out.println(&quot;Select the clicked word.&quot;);</span><br><span class="line">        editor.setState(new SelectionState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 其他操作方法...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端代码中，我们可以创建上下文对象<code>editor</code>，并根据用户的操作进行状态的改变和执行对应的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Editor editor = new Editor();</span><br><span class="line"></span><br><span class="line">        // 初始状态：默认状态</span><br><span class="line">        editor.click(); // 默认状态下的点击操作</span><br><span class="line"></span><br><span class="line">        // 切换到选择状态</span><br><span class="line">        editor.setState(new SelectionState());</span><br><span class="line">        editor.click(); // 选择状态下的点击操作</span><br><span class="line">        editor.doubleClick(); // 选择状态下的双击操作</span><br><span class="line"></span><br><span class="line">        // 切换到插入文本状态</span><br><span class="line">        editor.setState(new InsertTextState());</span><br><span class="line">        editor.click(); // 插入文本状态下的点击操作</span><br><span class="line">        editor.doubleClick(); // 插入文本状态下的双击操作</span><br><span class="line"></span><br><span class="line">        // 其他操作...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了上下文类<code>Editor</code>，并实现了状态接口<code>State</code>。具体状态类<code>SelectionState</code>和<code>InsertTextState</code>分别表示选择状态和插入文本状态，并实现了对应的操作方法。在客户端代码中，我们创建了一个上下文对象<code>editor</code>，通过调用<code>setState()</code>方法进行状态的切换，并调用对应状态下的操作方法。</p>
<p>通过使用状态模式，我们将不同的状态抽象成不同的状态类，使得每个状态的行为单独进行封装。这样，在新增状态时，只需实现新的状态类，并根据具体的需求实现对应的操作方法，而不需要修改原有的代码逻辑。状态模式将复杂的条件判断结构转移到状态类中，使得代码更加清晰、易读和易维护。</p>
<p>总结来说，状态模式通过将对象的行为封装在不同的状态类中，使得对象在不同的状态下可以表现出不同的行为。它能够将复杂的条件判断转化为状态类的方法调用，提高代码的可读性和可维护性。状态模式适用于对象的行为随内部状态的变化而变化的场景，能够有效地组织和管理对象的状态和行为</p>
<h4 id="9、策略模式（Strategy-Pattern）"><a href="#9、策略模式（Strategy-Pattern）" class="headerlink" title="9、策略模式（Strategy Pattern）"></a>9、策略模式（Strategy Pattern）</h4><p>策略模式（Strategy Pattern）是一种行为型设计模式，它允许在运行时选择算法的行为。该模式定义了一系列算法，并将每个算法封装在独立的策略类中，使得它们可以互相替换，而不影响客户端的使用。</p>
<p>策略模式的核心思想是将算法的实现与调用者解耦，使得调用者可以根据需要选择合适的策略来进行操作。通过使用策略模式，可以避免在代码中出现大量的条件判断语句，并提高系统的灵活性、可扩展性以及代码的可维护性。</p>
<p>策略模式的主要角色包括：</p>
<ul>
<li>Context（环境）：维护一个对策略接口的引用，并在运行时调用具体策略的算法。</li>
<li>Strategy（策略）：定义一个接口或抽象类，封装了算法的定义。</li>
<li>ConcreteStrategy（具体策略）：实现策略接口或继承抽象策略类，具体实现算法。</li>
</ul>
<p>为什么要使用策略模式呢？<br>当我们需要根据不同的情况选择不同的算法时，通常会使用条件语句（如if-else或switch语句）来实现。然而，当算法复杂度增加或需求变更时，维护和扩展这些条件语句变得困难且容易出错。而策略模式可以将每个算法封装在独立的策略类中，使得算法可以独立开发、测试和维护，并且能够在运行时动态地切换算法，从而提高代码的可读性、可维护性和可扩展性。</p>
<p>现在，让我们通过一个具体的例子来演示策略模式的用法。假设我们正在开发一个电商平台，该平台需要根据不同的支付方式计算订单的支付金额。</p>
<p>首先，定义一个策略接口<code>PaymentStrategy</code>，其中定义了计算支付金额的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface PaymentStrategy &#123;</span><br><span class="line">    double calculatePaymentAmount(double orderAmount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，实现具体的支付策略类，例如信用卡支付策略<code>CreditCardPaymentStrategy</code>和支付宝支付策略<code>AlipayPaymentStrategy</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class CreditCardPaymentStrategy implements PaymentStrategy &#123;</span><br><span class="line">    private static final double CREDIT_CARD_DISCOUNT = 0.1;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double calculatePaymentAmount(double orderAmount) &#123;</span><br><span class="line">        double discountAmount = orderAmount * CREDIT_CARD_DISCOUNT;</span><br><span class="line">        return orderAmount - discountAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class AlipayPaymentStrategy implements PaymentStrategy &#123;</span><br><span class="line">    private static final double ALIPAY_DISCOUNT = 0.05;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public double calculatePaymentAmount(double orderAmount) &#123;</span><br><span class="line">        double discountAmount = orderAmount * ALIPAY_DISCOUNT;</span><br><span class="line">        return orderAmount - discountAmount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端代码中，我们可以创建一个支付上下文对象<code>PaymentContext</code>，并根据用户选择的支付方式设置对应的支付策略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PaymentContext paymentContext = new PaymentContext();</span><br><span class="line"></span><br><span class="line">        // 选择信用卡支付</span><br><span class="line">        paymentContext.setPaymentStrategy(new CreditCardPaymentStrategy());</span><br><span class="line">        double orderAmount = 100.0;</span><br><span class="line">        double paymentAmount = paymentContext.calculatePaymentAmount(orderAmount);</span><br><span class="line">        System.out.println(&quot;支付金额：&quot; + paymentAmount);</span><br><span class="line"></span><br><span class="line">        // 选择支付宝支付</span><br><span class="line">        paymentContext.setPaymentStrategy(new AlipayPaymentStrategy());</span><br><span class="line">        paymentAmount = paymentContext.calculatePaymentAmount(orderAmount);</span><br><span class="line">        System.out.println(&quot;支付金额：&quot; + paymentAmount);</span><br><span class="line"></span><br><span class="line">        // 其他操作...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了策略接口<code>PaymentStrategy</code>，并实现了具体的支付策略类<code>CreditCardPaymentStrategy</code>和<code>AlipayPaymentStrategy</code>，分别代表信用卡支付和支付宝支付。在客户端代码中，我们创建一个支付上下文对象<code>PaymentContext</code>，并使用<code>setPaymentStrategy()</code>方法设置不同的支付策略。根据用户选择的支付方式，调用<code>calculatePaymentAmount()</code>方法计算支付金额。</p>
<p>通过使用策略模式，我们将不同算法的实现封装在不同的策略类中，实现了算法和调用者的解耦。这样，在新增支付方式时，只需实现新的支付策略类，而不需要修改原有的代码逻辑。策略模式使得代码结构清晰、可扩展性强，并且能够方便地增加新的策略和对应的算法。</p>
<p>总结来说，策略模式通过将算法的实现与调用者解耦，使得调用者可以在运行时选择合适的策略来进行操作。它能够避免使用大量的条件判断语句，并提高系统的灵活性和可维护性。策略模式适用于存在多种算法实现的情况下，能够灵活地切换算法，并且能够方便地扩展新增的算法。</p>
<h4 id="10、模板方法模式（Template-Method-Pattern）"><a href="#10、模板方法模式（Template-Method-Pattern）" class="headerlink" title="10、模板方法模式（Template Method Pattern）"></a>10、模板方法模式（Template Method Pattern）</h4><p>模板方法模式（Template Method Pattern）是一种行为型设计模式，它定义了一个操作算法的基本骨架，将某些步骤的具体实现延迟到子类中。模板方法模式允许子类在不改变算法结构的情况下，重新定义算法中的某些步骤。</p>
<p>模板方法模式的核心思想是将算法的通用流程定义在父类中，而将具体实现延迟到子类中。通过这种方式，模板方法模式提供了一种可扩展的算法骨架，使得在不同的子类中可以灵活地实现算法的具体细节。这样一来，算法的结构保持不变，但每个子类可以根据自己的需求来实现其中的具体步骤。</p>
<p>为什么要使用模板方法模式呢？<br>当我们在编写代码时，经常会遇到相似的操作算法，只有其中的一些细节不同。如果每次都复制相同的代码并修改细节，会导致代码重复，难以维护和扩展。而模板方法模式可以通过定义一个通用的算法骨架，在父类中实现通用的操作步骤，并将具体的实现细节留给子类来实现。这样，避免了代码重复，提高了代码的重用性、可维护性和可扩展性。</p>
<p>现在，让我们通过一个具体的例子来演示模板方法模式的用法。假设我们正在开发一个游戏应用，其中有多个角色需要展示自己的技能。</p>
<p>首先，定义一个抽象类<code>Character</code>作为角色的基类，其中包含展示技能的模板方法<code>showSkill()</code>，以及具体的技能步骤供子类实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Character &#123;</span><br><span class="line">    // 展示技能的模板方法</span><br><span class="line">    public final void showSkill() &#123;</span><br><span class="line">        System.out.println(&quot;角色技能展示开始：&quot;);</span><br><span class="line">        playAnimation();</span><br><span class="line">        playSound();</span><br><span class="line">        useSkill();</span><br><span class="line">        System.out.println(&quot;角色技能展示结束。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 播放动画</span><br><span class="line">    protected abstract void playAnimation();</span><br><span class="line"></span><br><span class="line">    // 播放音效</span><br><span class="line">    protected abstract void playSound();</span><br><span class="line"></span><br><span class="line">    // 使用技能</span><br><span class="line">    protected abstract void useSkill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建具体的角色类继承自<code>Character</code>，并实现其中的具体步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Warrior extends Character &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void playAnimation() &#123;</span><br><span class="line">        System.out.println(&quot;播放战士技能动画&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void playSound() &#123;</span><br><span class="line">        System.out.println(&quot;播放战士技能音效&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void useSkill() &#123;</span><br><span class="line">        System.out.println(&quot;战士使用技能：剑气斩&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Mage extends Character &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected void playAnimation() &#123;</span><br><span class="line">        System.out.println(&quot;播放法师技能动画&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void playSound() &#123;</span><br><span class="line">        System.out.println(&quot;播放法师技能音效&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void useSkill() &#123;</span><br><span class="line">        System.out.println(&quot;法师使用技能：火球术&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端代码中，我们可以创建不同的角色对象，并调用它们的<code>showSkill()</code>方法，该方法会按照预定义的算法骨架展示角色的技能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Character warrior = new Warrior();</span><br><span class="line">        warrior.showSkill();</span><br><span class="line"></span><br><span class="line">        Character mage = new Mage();</span><br><span class="line">        mage.showSkill();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了抽象类<code>Character</code>作为角色的基类，并在其中定义了展示技能的模板方法<code>showSkill()</code>。然后，我们创建了具体的角色类<code>Warrior</code>和<code>Mage</code>，分别表示战士和法师，这两个类继承自<code>Character</code>，并实现了具体的技能步骤。在客户端代码中，我们创建了战士和法师对象，并调用它们的<code>showSkill()</code>方法来展示角色的技能。</p>
<p>通过使用模板方法模式，我们将展示技能的通用操作放在了父类的模板方法中，而将具体的实现细节留给子类来实现。这样，在新增角色时，只需创建对应的子类，并实现自己的技能步骤即可，而不需要修改父类的代码。模板方法模式使得代码结构清晰、可扩展性强，并且能够方便地增加新的子类和对应的实现细节。</p>
<p>总结来说，模板方法模式通过定义一个操作算法的基本骨架，并将具体实现延迟到子类中，实现了算法的通用流程与具体实现的分离。它能够避免代码重复，提高代码的重用性、可维护性和可扩展性。模板方法模式适用于存在相似操作算法的情况下，能够保持算法的结构稳定，并在子类中灵活地实现算法的具体细节。</p>
<h4 id="11、访问者模式（Visitor-Pattern）"><a href="#11、访问者模式（Visitor-Pattern）" class="headerlink" title="11、访问者模式（Visitor Pattern）"></a>11、访问者模式（Visitor Pattern）</h4><p>访问者模式（Visitor Pattern）是一种行为型设计模式，它允许在不修改已有类的前提下，定义新的操作并应用于这些类的对象上。访问者模式将数据结构和对数据的操作分离，使得操作独立于数据结构，从而增加新的操作变得更加灵活和扩展。</p>
<p>访问者模式的核心思想是定义一个抽象的访问者（Visitor），其中包含一系列的访问方法，用于处理不同类型的元素。然后，为每种元素定义一个接受访问者的方法，该方法将访问者作为参数，并调用访问者的相应访问方法。通过这种方式，元素将自己暴露给访问者，让访问者处理自身。这样一来，当需要新增一种操作时，只需要实现新的访问者，并将其应用于元素上，而无需修改元素本身。</p>
<p>为什么要使用访问者模式呢？<br>当我们需要在不修改已有类的情况下，增加新的操作或处理逻辑时，访问者模式非常有用。它将操作和数据结构解耦，使得操作可以独立扩展，而不影响现有的数据结构。此外，访问者模式还可以避免使用大量的条件语句来判断对象的类型，提高代码的可读性和可维护性。</p>
<p>接下来，让我们通过一个具体的例子来更详细地了解访问者模式的用法。假设我们正在开发一个图形编辑器，其中包含多种形状（如圆形、矩形等）和颜色（如红色、蓝色等）。我们希望能够实现一些操作，例如计算所有形状的面积之和、将所有形状的颜色修改为指定颜色等。</p>
<p>首先，定义一个抽象类<code>Shape</code>作为形状的基类，其中声明了一个接受访问者的方法<code>accept()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Shape &#123;</span><br><span class="line">    public abstract void accept(Visitor visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建具体的形状类继承自<code>Shape</code>，并实现其中的接受访问者的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Circle extends Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Visitor visitor) &#123;</span><br><span class="line">        visitor.visitCircle(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Rectangle extends Shape &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(Visitor visitor) &#123;</span><br><span class="line">        visitor.visitRectangle(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，定义一个抽象类<code>Visitor</code>作为访问者的基类，其中声明了一系列的访问方法，用于处理不同类型的形状：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class Visitor &#123;</span><br><span class="line">    public abstract void visitCircle(Circle circle);</span><br><span class="line">    public abstract void visitRectangle(Rectangle rectangle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建具体的访问者类，例如<code>AreaVisitor</code>和<code>ColorVisitor</code>，分别用于计算面积和修改颜色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AreaVisitor</span> <span class="keyword">extends</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">totalArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCircle</span><span class="params">(Circle circle)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> Math.PI * Math.pow(circle.getRadius(), <span class="number">2</span>);</span><br><span class="line">        totalArea += area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitRectangle</span><span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> rectangle.getWidth() * rectangle.getHeight();</span><br><span class="line">        totalArea += area;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getTotalArea</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> totalArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorVisitor</span> <span class="keyword">extends</span> <span class="title class_">Visitor</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitCircle</span><span class="params">(Circle circle)</span> &#123;</span><br><span class="line">        circle.setColor(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">visitRectangle</span><span class="params">(Rectangle rectangle)</span> &#123;</span><br><span class="line">        rectangle.setColor(color);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setColor</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在客户端代码中，我们可以创建不同的形状对象，并应用不同的访问者操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        List&lt;Shape&gt; shapes = new ArrayList&lt;&gt;();</span><br><span class="line">        shapes.add(new Circle(5));</span><br><span class="line">        shapes.add(new Rectangle(3, 4));</span><br><span class="line"></span><br><span class="line">        AreaVisitor areaVisitor = new AreaVisitor();</span><br><span class="line">        for (Shape shape : shapes) &#123;</span><br><span class="line">            shape.accept(areaVisitor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;Total area: &quot; + areaVisitor.getTotalArea());</span><br><span class="line"></span><br><span class="line">        ColorVisitor colorVisitor = new ColorVisitor();</span><br><span class="line">        colorVisitor.setColor(&quot;Red&quot;);</span><br><span class="line">        for (Shape shape : shapes) &#123;</span><br><span class="line">            shape.accept(colorVisitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，我们定义了抽象类<code>Shape</code>作为形状的基类，并在其中声明了一个接受访问者的方法<code>accept()</code>。然后，我们创建了具体的形状类<code>Circle</code>和<code>Rectangle</code>，它们继承自<code>Shape</code>，并实现了接受访问者的方法。</p>
<p>接着，我们定义了抽象类<code>Visitor</code>作为访问者的基类，并在其中声明了一系列的访问方法，用于处理不同类型的形状。然后，我们创建了具体的访问者类<code>AreaVisitor</code>和<code>ColorVisitor</code>，分别用于计算面积和修改颜色。</p>
<p>在客户端代码中，我们创建了多个形状对象，并将它们放入一个列表中。然后，我们创建了一个<code>AreaVisitor</code>对象，通过遍历形状列表，调用每个形状的<code>accept()</code>方法，并传入<code>AreaVisitor</code>对象，从而实现对形状的面积计算。最后，我们输出计算得到的总面积。</p>
<p>接着，我们创建了一个<code>ColorVisitor</code>对象，将颜色设置为红色，并通过遍历形状列表，调用每个形状的<code>accept()</code>方法，并传入<code>ColorVisitor</code>对象，实现对形状颜色的修改。</p>
<p>通过使用访问者模式，我们将数据结构（形状）与操作（计算面积、修改颜色）进行了分离，使得操作可以独立扩展，而不影响现有的数据结构。当需要新增一种操作时，只需实现新的访问者，并将其应用于形状上，而无需修改形状本身。这样，我们可以灵活地添加、修改和扩展操作，同时保持代码的可读性和可维护性。</p>
<p>总结来说，访问者模式通过定义一个抽象的访问者，并在具体的数据结构中实现接受访问者的方法，将操作与数据结构解耦，从而使得操作可以独立扩展。它适用于需要在不修改已有类的情况下，对已有类进行新的操作或处理逻辑的场景。通过使用访问者模式，我们可以避免使用大量的条件语句来处理不同类型的对象，提高代码的可读性和可维护性。</p>
<p>请注意，这只是23种常见的设计模式，还有其他的设计模式也值得了解和学习。每种设计模式都有其特定的应用场景和优缺点，根据项目需求和设计目标选择合适的设计模式来最大化效益</p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://stress1110.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://stress1110.github.io/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
