<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Stress's blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Stress</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        <a class="category-link" href="/categories/JUC/">JUC</a></li><li><a class="category-link" href="/categories/%E5%BC%82%E5%B8%B8/">异常</a></li><li><a class="category-link" href="/categories/%E9%85%8D%E7%BD%AE/">配置</a></li><li><a class="category-link" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></li><li><a class="category-link" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a>
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url(/pic/8.jpg);background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >关于caffeine</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="Caffeine"><a href="#Caffeine" class="headerlink" title="Caffeine"></a>Caffeine</h1><h2 id="什么是Caffeine？"><a href="#什么是Caffeine？" class="headerlink" title="什么是Caffeine？"></a>什么是Caffeine？</h2><p>Caffeine 是一个开源的 Java 缓存库，用于提供高性能的内存缓存解决方案。它被设计用于替代 Java 标准库中的 ConcurrentHashMap，以提供更强大和灵活的缓存功能。Caffeine 的目标是提供快速、高性能的缓存，并且在多线程环境下表现出色。<br>以下是一些 Caffeine 的主要特点和优势：</p>
<p>1.高性能：Caffeine 使用了一系列性能优化技术，包括非阻塞数据结构和内存管理，以确保快速的读写操作。它在吞吐量和响应时间方面都表现出色。<br>2.自动驱逐策略：Caffeine 支持多种驱逐策略，如基于大小、基于时间或基于访问顺序的驱逐策略。这使得可以自动清理不再需要的缓存条目，以防止内存泄漏和资源浪费。<br>3.异步加载：Caffeine 允许异步加载缓存条目，这意味着当缓存中不存在所需的数据时，可以在后台线程中加载数据，而不会阻塞主线程。<br>4.统计信息和监听器：Caffeine 提供了丰富的统计信息和监听器，可以用于监视缓存的性能和行为，以便进行调优和故障排除。<br>5.大小可调：Caffeine 允许你为缓存设置最大大小，以防止内存过度使用。你可以根据应用程序的需求来调整缓存的大小。<br>6.线程安全：Caffeine 提供了线程安全的缓存实现，适用于多线程环境。</p>
<p>Caffeine 在许多 Java 应用程序中被广泛使用，特别是在需要高性能缓存的场景中，如Web应用程序、分布式系统、数据访问层等。它提供了一个强大而可定制的缓存解决方案，可以显著提高应用程序的性能和响应速度。</p>
<img src="/%E5%85%B3%E4%BA%8Ecaffeine/image-20231102225624924.png" alt="image-20231102225624924" style="zoom: 200%;">

<p>以上是ChatGPT的回答，可以说总结的很到位了。下面我会通过阅读其他文章，更深度地讲解我所理解的Caffeine。（ps:我在项目里使用Caffeine，而且面试的时候也问了。)</p>
<h2 id="什么时候需要使用缓存呢？"><a href="#什么时候需要使用缓存呢？" class="headerlink" title="什么时候需要使用缓存呢？"></a>什么时候需要使用缓存呢？</h2><p>一共有两种情况：</p>
<p>1、CPU占用——缓存计算结果：查询的数据需要经过大量的或复杂的计算</p>
<p>2、数据库I&#x2F;O占用——并发高，访问频繁：一段时间内被反复查询的数据（热点数据）</p>
<h2 id="为什么要用Caffeine呢？"><a href="#为什么要用Caffeine呢？" class="headerlink" title="为什么要用Caffeine呢？"></a>为什么要用Caffeine呢？</h2><p>也可以从两个角度作比较：</p>
<h3 id="1、首先是远程缓存（Redis）"><a href="#1、首先是远程缓存（Redis）" class="headerlink" title="1、首先是远程缓存（Redis）"></a>1、首先是远程缓存（Redis）</h3><p>Redis经常被用作缓存的中间件，面试被问到，“竟然有了Redis，为什么还要使用Caffeine？”</p>
<ul>
<li>Redis可能会挂了或者老版本的Redis（会进行全量同步），这种情况远程缓存不可用，容易造成缓存雪崩的情况</li>
<li>网络I&#x2F;O以及序列化&#x2F;反序列化的速度不够快，毕竟作为远程的服务器，还是需要经过网络传输这个过程，且网络不一定可靠。</li>
</ul>
<h3 id="2、其次是本地缓存"><a href="#2、其次是本地缓存" class="headerlink" title="2、其次是本地缓存"></a>2、其次是本地缓存</h3><p>在Caffeine出现之前，都是用的什么本地缓存呢；这里涉及到缓存的进化史</p>
<p><strong>HashMap —&gt; LURHashMap —&gt; Guava cache —&gt; Caffeine</strong></p>
<p>在流量不大的时候，查数据库或者读取文件是最为方便，也能完全满足我们的业务要求。</p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><p>当我们应用有一定流量之后或者查询数据库特别频繁,这个时候就可以使用Java中自带的HashMap或者ConcurrentHashMap。</p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>简单易用，是Java标准库的一部分，无需额外的依赖。</li>
<li>快速的O(1)查找时间复杂度（在理想情况下）。</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>无法进行数据淘汰，内存会无限制的增长</li>
<li>多线程环境下需要手动处理同步问题，否则可能会出现并发问题</li>
</ul>
<h4 id="LURHashMap"><a href="#LURHashMap" class="headerlink" title="LURHashMap"></a>LURHashMap</h4><p>为了解决内存无线膨胀，聪明的人们发明了几种淘汰算法，下面列举最为常见的三种FIFO，LRU，LFU</p>
<h5 id="FIFO（先进先出）"><a href="#FIFO（先进先出）" class="headerlink" title="FIFO（先进先出）"></a>FIFO（先进先出）</h5><p>在这种淘汰算法中，先进入缓存的会先被淘汰。这种可谓是最简单的了，但是会导致我们命中率很低。试想一下我们如果有个访问频率很高的数据是所有数据第一个访问的，而那些不是很高的是后面再访问的，那这样就会把我们的首个数据但是他的访问频率很高给挤出。</p>
<h5 id="LRU（最近最少使用）"><a href="#LRU（最近最少使用）" class="headerlink" title="LRU（最近最少使用）"></a>LRU（最近最少使用）</h5><p>在这种算法中避免了上面的问题，每次访问数据都会将其放在我们的队尾，如果需要淘汰数据，就只需要淘汰队首即可。但是这个依然有个问题，如果有个数据在1个小时的前59分钟访问了1万次(可见这是个热点数据),再后一分钟没有访问这个数据，但是有其他的数据访问，就导致了我们这个热点数据被淘汰。</p>
<h5 id="LFU（最近最少频率使用）"><a href="#LFU（最近最少频率使用）" class="headerlink" title="LFU（最近最少频率使用）"></a>LFU（最近最少频率使用）</h5><p>在这种算法中又对上面进行了优化，利用额外的空间记录每个数据的使用频率，然后选出频率最低进行淘汰。这样就避免了LRU不能处理时间段的问题。</p>
<p>上面列举了三种淘汰策略，对于这三种，实现成本是一个比一个高，同样的命中率也是一个比一个好。而我们一般来说选择的方案居中即可，即实现成本不是太高，而命中率也还行的LRU,如何实现一个LRUMap呢？</p>
<p>下面是一个简单的基于 LinkedHashMap 的 LURMap 的 Java 实现示例：</p>
<p><code>LinkedHashMap</code>的特性使得它非常适合实现LRU缓存。通过设置<code>LinkedHashMap</code>的<code>accessOrder</code>参数为<code>true</code>，它会根据元素的访问顺序来进行排列，最近访问的元素会被放在最后，最少访问的元素会被放在最前面。</p>
<h5 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUMap</span>&lt;K, V&gt; <span class="keyword">extends</span> <span class="title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> max;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUMap</span><span class="params">(<span class="type">int</span> max, Object lock)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>((max * <span class="number">1.4f</span>), <span class="number">0.75f</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.max = max;</span><br><span class="line">        <span class="built_in">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size() &gt; max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">getValue</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> get(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putValue</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            put(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeValue</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> remove(key) != <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeAll</span><span class="params">()</span> &#123;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 示例用法</span></span><br><span class="line">        LRUMap&lt;String, Integer&gt; lruMap = <span class="keyword">new</span> <span class="title class_">LRUMap</span>&lt;&gt;(<span class="number">3</span>, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line"></span><br><span class="line">        lruMap.putValue(<span class="string">&quot;one&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        lruMap.putValue(<span class="string">&quot;two&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        lruMap.putValue(<span class="string">&quot;three&quot;</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(lruMap.getValue(<span class="string">&quot;one&quot;</span>)); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(lruMap.getValue(<span class="string">&quot;two&quot;</span>)); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">        lruMap.putValue(<span class="string">&quot;four&quot;</span>, <span class="number">4</span>);  <span class="comment">// 触发LRU，移除最老的元素 &quot;three&quot;</span></span><br><span class="line"></span><br><span class="line">        System.out.println(lruMap.getValue(<span class="string">&quot;three&quot;</span>)); <span class="comment">// null，因为&quot;three&quot;已被移除</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>在LinkedHashMap中维护了一个entry(用来放key和value的对象)链表。在每一次get或者put的时候都会把插入的新entry，或查询到的老entry放在我们链表末尾。可以注意到我们在构造方法中，设置的大小特意设置到max*1.4，在下面的removeEldestEntry方法中只需要size&gt;max就淘汰，这样我们这个map永远也走不到扩容的逻辑了，通过重写LinkedHashMap，几个简单的方法我们实现了我们的LruMap。</p>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>锁竞争严重，Lock是全局锁，在方法级别上面，当调用量较大时，性能必然会比较低</li>
<li>不支持过期时间</li>
<li>不支持自动刷新</li>
</ul>
<h4 id="Guava-cache"><a href="#Guava-cache" class="headerlink" title="Guava cache"></a>Guava cache</h4><p>针对LURHashMap的缺点，大佬们发明了Guava cache，在Guava cache中，可以像下面的代码一样，轻松的使用：</p>
<h5 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException &#123;</span><br><span class="line">       LoadingCache&lt;String, String&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">               .maximumSize(<span class="number">100</span>)</span><br><span class="line">               <span class="comment">//写之后30ms过期</span></span><br><span class="line">               .expireAfterWrite(<span class="number">30L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">               <span class="comment">//访问之后30ms过期</span></span><br><span class="line">               .expireAfterAccess(<span class="number">30L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">               <span class="comment">//20ms之后刷新</span></span><br><span class="line">               .refreshAfterWrite(<span class="number">20L</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">               <span class="comment">//开启weakKey key 当启动垃圾回收时，该缓存也被回收</span></span><br><span class="line">               .weakKeys()</span><br><span class="line">               .build(createCacheLoader());</span><br><span class="line">       System.out.println(cache.get(<span class="string">&quot;hello&quot;</span>));</span><br><span class="line">       cache.put(<span class="string">&quot;hello1&quot;</span>, <span class="string">&quot;我是hello1&quot;</span>);</span><br><span class="line">       System.out.println(cache.get(<span class="string">&quot;hello1&quot;</span>));</span><br><span class="line">       cache.put(<span class="string">&quot;hello1&quot;</span>, <span class="string">&quot;我是hello2&quot;</span>);</span><br><span class="line">       System.out.println(cache.get(<span class="string">&quot;hello1&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> com.google.common.cache.CacheLoader&lt;String, String&gt; <span class="title function_">createCacheLoader</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">com</span>.google.common.cache.CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="keyword">public</span> String <span class="title function_">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">               <span class="keyword">return</span> key;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="锁竞争"><a href="#锁竞争" class="headerlink" title="锁竞争"></a>锁竞争</h5><p>guava cache采用了<strong>类似ConcurrentHashMap的思想</strong>，分段加锁，在每个段里面各自负责自己的淘汰的事情。在Guava根据一定的算法进行分段，这里要说明的是，如果段太少那竞争依然很严重，如果段太多会容易出现随机淘汰，比如大小为100的，给他分100个段，那也就是让每个数据都独占一个段，而每个段会自己处理淘汰的过程，所以会出现随机淘汰。</p>
<h5 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h5><p>相比于LRUMap多了两种过期时间，一个是写后多久过期expireAfterWrite，一个是读后多久过期expireAfterAccess。很有意思的事情是，在guava cache中对于过期的Entry并没有马上过期(也就是并没有后台线程一直在扫)，而是通过进行读写操作的时候进行过期处理，这样做的好处是避免后台线程扫描的时候进行全局加锁。</p>
<p>上面说过，guava cache 是以段位单位进行过期处理。在每个Segment中维护了两个队列，分别用于维护缓存的访问顺序和管理并发写入操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读队列</span></span><br><span class="line"><span class="keyword">final</span> Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; accessQueue;</span><br><span class="line"><span class="comment">//写队列</span></span><br><span class="line"><span class="keyword">final</span> Queue&lt;ReferenceEntry&lt;K, V&gt;&gt; writeQueue;</span><br></pre></td></tr></table></figure>

<p>Guava Cache维护两个队列（写队列和读队列）的设计是为了在不同的场景下进行高效的缓存管理。</p>
<ul>
<li><p>读队列（Access Queue）：</p>
<ul>
<li>读队列用于维护缓存中已经被访问的条目，以支持缓存的”最近最少使用”（LRU）策略。</li>
<li>当一个缓存条目被访问（读取或者被查询）时，它会被移动到读队列的末尾，表示它是最近被访问过的。</li>
<li>当缓存达到最大容量时，会从读队列的开头移除最近最少使用的缓存条目，以腾出空间给新的条目。</li>
</ul>
</li>
<li><p>写队列（Write Queue）：</p>
<ul>
<li>写队列用于维护正在写入缓存的条目，以支持并发写操作。</li>
<li>当多个线程同时尝试写入相同的缓存键时，写队列可以确保只有一个线程进行实际的写操作，而其他线程等待。</li>
<li>写队列的目的是避免多线程写入相同键时可能引发的竞争条件。</li>
</ul>
</li>
</ul>
<p>读队列支持LRU策略，确保缓存中最近最少使用的条目被淘汰，如果当这个Segment超过最大容量，就会把读队列的第一个元素进行淘汰。</p>
<p>而写队列用于确保并发写入时的线程安全性，主要用于处理写入并发。</p>
<h5 id="自动刷新"><a href="#自动刷新" class="headerlink" title="自动刷新"></a>自动刷新</h5><p>自动刷新操作，在guava cache中实现相对比较简单，直接通过查询，判断其是否满足刷新条件，进行刷新。</p>
<h5 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h5><p>虚引用</p>
<p>删除监听器：</p>
<p>在guava cache中，当有数据被淘汰时，但是你不知道他到底是过期，还是被驱逐，还是因为虚引用的对象被回收？这个时候你可以调用这个方法removalListener(RemovalListener listener)添加监听器进行数据淘汰的监听，可以打日志或者一些其他处理，可以用来进行数据淘汰分析。</p>
<h5 id="guava-cache的总结"><a href="#guava-cache的总结" class="headerlink" title="guava cache的总结"></a>guava cache的总结</h5><p>一个性能不错的，api丰富的LRU Map。</p>
<h4 id="Caffeine-1"><a href="#Caffeine-1" class="headerlink" title="Caffeine"></a>Caffeine</h4><p>guava cache的功能的确是很强大，满足了绝大多数的人的需求，但是其本质上还是LRU的一层封装,所以在众多其他较为优良的淘汰算法中就相形见绌了。而caffeine cache实现了W-TinyLFU(LFU+LRU算法的变种)。</p>
<p>Caffeine不仅仅是命中率caffeine优于了guava cache，在读写吞吐量上面也是完爆guava cache。</p>
<h5 id="W-TinyLFU"><a href="#W-TinyLFU" class="headerlink" title="W-TinyLFU"></a>W-TinyLFU</h5><p>W-TinyLFU结合了LRU和LFU，以及其他的算法的一些特点。</p>
<p>在LFU中只要数据访问模式的概率分布随时间保持不变时，其命中率就能变得非常高。而LRU可以很好的应对突发流量的情况，因为他不需要累计数据频率。</p>
<h5 id="频率记录"><a href="#频率记录" class="headerlink" title="频率记录"></a>频率记录</h5><p>我们要实现的目标是利用有限的空间可以记录随时间变化的访问频率。在W-TinyLFU中使用Count-Min Sketch记录我们的访问频率，而这个也是布隆过滤器的一种变种。如下图所示:</p>
<p><img src="/%E5%85%B3%E4%BA%8Ecaffeine/1654122a489af624~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.webp" alt="1654122a489af624~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75"></p>
<p>如果需要记录一个值，那我们需要通过多种Hash算法对其进行处理hash，然后在对应的hash算法的记录中+1，为什么需要多种hash算法呢？由于这是一个压缩算法必定会出现冲突</p>
<h5 id="读写性能"><a href="#读写性能" class="headerlink" title="读写性能"></a>读写性能</h5><p>在guava cache中我们说过其读写操作中夹杂着过期时间的处理，也就是你在一次Put操作中有可能还会做淘汰操作，所以其读写性能会受到一定影响。</p>
<p>而Caffeine对这些事件的操作是通过异步操作，他将事件提交至队列<strong>Disruptor</strong>，这里的队列的数据结构是RingBuffer。</p>
<p>对于写操作是所有线程共享一个RingBuffer。而由于读操作比写操作更加频繁，为了进一步减少竞争，为每个线程配备了一个RingBuffer。</p>
<h5 id="关于Disruptor"><a href="#关于Disruptor" class="headerlink" title="关于Disruptor"></a>关于Disruptor</h5><p>有了这三大杀器，Disruptor才变得如此牛逼。</p>
<ul>
<li><strong>CAS</strong></li>
</ul>
<p>ArrayBlockingQueue为什么会被抛弃的一点，就是因为用了重量级lock锁，在我们加锁过程中我们会把锁挂起，解锁后，又会把线程恢复,这一过程会有一定的开销，并且我们一旦没有获取锁，这个线程就只能一直等待，这个线程什么事也不能做。</p>
<ul>
<li><strong>消除伪共享</strong></li>
</ul>
<p>缓存行的大小通常是64字节，在Java中Long是8个字节，所以可以存储8个Long,举个例子，你访问一个long的变量的时候，他会把帮助再加载7个，我们上面说为什么选择数组不选择链表，也就是这个原因，在数组中可以依靠缓冲行得到很快的访问。</p>
<p>解决缓存行出现的问题：对于maxSize是我们一开始就定义好的，数组的大小，对于currentIndex，是标志我们当前队列的位置，这个变化比较快，可以想象你访问maxSize的时候，是不是把currentIndex也加载进来了，这个时候，其他线程更新currentIndex,就会把cpu中的缓存行置位无效，请注意这是CPU规定的，他并不是只吧currentIndex置位无效，如果此时又继续访问maxSize他依然得继续从内存中读取，但是MaxSize却是我们一开始定义好的，我们应该访问缓存即可，但是却被我们经常改变的currentIndex所影响。</p>
<p>解决：</p>
<p>将其中的Value就被其他一些无用的long变量给填充了。这样你修改Value的时候，就不会影响到其他变量的缓存行。</p>
<ul>
<li><strong>RingBuffer</strong></li>
</ul>
<p>在Disruptor中进一步选择采用了环形数组进行保存数据，也就是RingBuffer。这里的环形数组并不是真正的环形数组，在RingBuffer中是采用取余的方式进行访问的</p>
<blockquote>
<p>实际上，在这些框架中取余并不是使用%运算，都是使用的&amp;与运算，这就要求你设置的大小一般是2的N次方也就是，10,100,1000等等，这样减去1的话就是，1，11，111，就能很好的使用index &amp; (size -1),这样利用位运算就增加了访问速度。 如果在Disruptor中你不用2的N次方进行大小设置，他会抛出buffersize必须为2的N次方异常。</p>
</blockquote>
<p>不仅解决了数组快速访问的问题，也解决了不需要再次分配内存的问题，减少了垃圾回收，因为我们0，10，20等都是执行的同一片内存区域，这样就不需要再次分配内存，频繁的被JVM垃圾回收器回收。</p>
<p><img src="/%E5%85%B3%E4%BA%8Ecaffeine/164ea1033b955f2e~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.png" alt="164ea1033b955f2e~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75"></p>
<h5 id="数据淘汰策略"><a href="#数据淘汰策略" class="headerlink" title="数据淘汰策略"></a>数据淘汰策略</h5><p>在caffeine所有的数据都在ConcurrentHashMap中，这个和guava cache不同，guava cache是自己实现了个类似ConcurrentHashMap的结构。</p>
<p>在caffeine中有三个记录引用的<strong>LRU</strong>队列:</p>
<ul>
<li>Eden队列:在caffeine中规定只能为缓存容量的%1,如果size&#x3D;100,那这个队列的有效大小就等于1。这个队列中记录的是新到的数据，防止突发流量由于之前没有访问频率，而导致被淘汰。比如有一部新剧上线，在最开始其实是没有访问频率的，防止上线之后被其他缓存淘汰出去，而加入这个区域。伊甸区，最舒服最安逸的区域，在这里很难被其他数据淘汰。</li>
<li>Probation队列:叫做缓刑队列，在这个队列就代表你的数据相对比较冷，马上就要被淘汰了。这个有效大小为size减去eden减去protected。</li>
<li>Protected队列:在这个队列中，可以稍微放心一下了，你暂时不会被淘汰，但是别急，如果Probation队列没有数据了或者Protected数据满了，你也将会被面临淘汰的尴尬局面。当然想要变成这个队列，需要把Probation访问一次之后，就会提升为Protected队列。这个有效大小为(size减去eden) X 80% 如果size &#x3D;100，就会是79。</li>
</ul>
<p><strong>这三个队列关系如下！！！！！</strong></p>
<p><img src="/%E5%85%B3%E4%BA%8Ecaffeine/1654222b063487e1~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75.webp" alt="1654222b063487e1~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75"></p>
<ol>
<li>所有的新数据都会进入Eden。</li>
<li>Eden满了，淘汰进入Probation。</li>
<li>如果在Probation中访问了其中某个数据，则这个数据升级为Protected。</li>
<li>如果Protected满了又会继续降级为Probation。</li>
</ol>
<h5 id="如何使用？-1"><a href="#如何使用？-1" class="headerlink" title="如何使用？"></a>如何使用？</h5><p>caffeine的api借鉴了Guava的api，可以发现其基本一模一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Cache&lt;String, String&gt; cache = Caffeine.newBuilder()</span><br><span class="line">                .expireAfterWrite(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                .expireAfterAccess(<span class="number">1</span>,TimeUnit.SECONDS)</span><br><span class="line">                .maximumSize(<span class="number">10</span>)</span><br><span class="line">                .build();</span><br><span class="line">        cache.put(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上为整个缓存的进化史，结合着其他缓存的与Caffeine作对比，再看一下开头所总结的内容，会不会加深你对Caffeine的理解呢？</p>
<p><img src="/%E5%85%B3%E4%BA%8Ecaffeine/image-20231102225624924.png" alt="image-20231102225624924"></p>
<p><img src="/%E5%85%B3%E4%BA%8Ecaffeine/%E5%AE%8C%E7%BB%93%E6%92%92%E8%8A%B1.gif" alt="完结撒花"></p>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'https://stress1110.github.io/%E5%85%B3%E4%BA%8Ecaffeine/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'https://stress1110.github.io/%E5%85%B3%E4%BA%8Ecaffeine/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
